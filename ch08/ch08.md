# 8장. 일반적인 컬렉션 (Common Collections)

러스트 표준 라이브러리에는 자주 쓰이는 세 가지 대표적인 컬렉션 타입이 있습니다.
이 장에서는 각각의 사용법, 특징, 그리고 주의할 점을 정리합니다.

* `Vec<T>`: 같은 타입의 값들을 순서대로 저장하는 동적 배열
* `String`: UTF-8 텍스트를 저장하는 가변적 컬렉션
* `HashMap<K, V>`: 키와 값을 연관 지어 저장하는 해시 테이블

---

## 1. 벡터 (`Vec<T>`)

### 생성

```rust
// 빈 벡터 생성
let v: Vec<i32> = Vec::new();

// 초기값과 함께 생성
let v = vec![1, 2, 3];
```

* `Vec::new()` → 빈 벡터
* `vec![]` 매크로 → 편리하게 초기값 설정

### 값 추가 / 읽기

```rust
let mut v = vec![1, 2];
v.push(3); // 값 추가

let third = &v[2];      // 인덱스 접근 (존재하지 않으면 panic)
let third = v.get(2);   // 안전한 접근 (Option 반환)
```

* 인덱스 `[]`: 존재하지 않으면 **패닉 발생**
* `get()`: `Option<&T>` 반환 → 안전한 처리 가능

### 반복

```rust
for i in &v {
    println!("{i}");
}

for i in &mut v {
    *i += 50;
}
```

* 불변 참조 / 가변 참조로 반복 가능

### 여러 타입 저장

* 벡터는 **동일 타입만 저장 가능**
* 서로 다른 타입을 저장하려면 \*\*열거형(enum)\*\*을 정의해서 사용

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(10),
    SpreadsheetCell::Text(String::from("blue")),
];
```

---

## 2. 문자열 (`String`)

### 특징

* 내부적으로 `Vec<u8>` 기반
* UTF-8 인코딩된 텍스트 저장
* `String`과 `&str` 모두 자주 사용됨

### 생성

```rust
let s = String::new();
let s = "hello".to_string();
let s = String::from("hello");
```

### 수정

```rust
let mut s = String::from("foo");
s.push_str("bar"); // 문자열 추가
s.push('!');       // 문자 추가

let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1은 이동됨
```

* `+` 연산자 → `s1` 이동, `s2` 참조 사용
* 여러 문자열 결합 시 `format!` 매크로 추천

  ```rust
  let s = format!("{}-{}-{}", "tic", "tac", "toe");
  ```

### 인덱싱 불가

```rust
let s = String::from("Здравствуйте");
// let h = s[0]; // 컴파일 에러
```

* 이유: UTF-8 → 한 문자가 여러 바이트일 수 있음

### 안전한 접근 방법

```rust
for c in "Зд".chars() {  // 유니코드 스칼라 값 단위
    println!("{c}");
}

for b in "Зд".bytes() {  // 바이트 단위
    println!("{b}");
}
```

* 필요 시 `chars()`, `bytes()` 메서드를 사용

---

## 3. 해시맵 (`HashMap<K, V>`)

### 생성 및 삽입

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

* 키와 값 모두 같은 타입이어야 함
* `HashMap`은 Prelude에 포함되지 않음 → `use` 필요

### 접근

```rust
let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
```

* `get()` → `Option<&V>` 반환

### 반복

```rust
for (key, value) in &scores {
    println!("{key}: {value}");
}
```

### 소유권

```rust
let field_name = String::from("Favorite color");
let field_value = String::from("Blue");
scores.insert(field_name, field_value);
// field_name, field_value는 더 이상 사용 불가
```

* `String` 같은 값은 해시맵으로 **이동**됨

### 업데이트

* **덮어쓰기**

  ```rust
  scores.insert(String::from("Blue"), 25);
  ```
* **없을 때만 추가 (`entry().or_insert()`)**

  ```rust
  scores.entry(String::from("Yellow")).or_insert(50);
  ```
* **기존 값 기반 업데이트**

  ```rust
  let text = "hello world wonderful world";
  let mut map = HashMap::new();

  for word in text.split_whitespace() {
      let count = map.entry(word).or_insert(0);
      *count += 1;
  }
  ```

### 해시 함수

* 기본적으로 **SipHash** 사용 → 보안성이 높음
* 필요 시 다른 해시어로 교체 가능

---

## 정리

* **벡터(Vec)**: 동적 배열, 같은 타입만 저장 가능
* **문자열(String)**: UTF-8 기반, 인덱싱 불가, `chars()`/`bytes()` 사용
* **해시맵(HashMap)**: 키-값 저장, `entry` API로 값 삽입/갱신

→ 러스트에서 데이터를 **저장·수정·검색**하는 데 핵심적으로 사용되는 도구들임.
