# 10장: 제네릭, 트레이트, 라이프타임 요약

이 장에서는 **제네릭(generics)**, **트레이트(traits)**, **라이프타임(lifetimes)** 이라는 러스트의 핵심 개념을 다룹니다. 이 세 가지는 코드의 **재사용성**, **추상화**, **안전성**을 높이는 데 중요한 역할을 합니다.

---

## 1. 제네릭 (Generics)

* **정의**: 여러 타입에서 동작할 수 있도록 만드는 추상화 도구.
* **사용법**: 함수, 구조체, 열거형, 메서드 등에 `<T>` 형태로 선언.
* **예시**:

```rust
// 제네릭 함수
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
```

→ `i32`, `char`, `f64` 등 다양한 타입에 재사용 가능.

---

## 2. 트레이트 (Traits)

* **정의**: 타입들이 공통적으로 가져야 할 동작(메서드 집합)을 정의.
* **인터페이스(interface)와 유사**하지만, 기본 구현을 제공할 수 있음.
* **구현 방법**:

```rust
// 트레이트 정의
pub trait Summary {
    fn summarize(&self) -> String;
}

// 특정 타입에 트레이트 구현
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

* **트레이트 바운드 (trait bound)**

    * 제네릭에 특정 트레이트를 요구할 수 있음.
    * `fn notify<T: Summary>(item: &T)` → `item`은 반드시 `Summary`를 구현해야 함.

* **기본 구현 (default implementation)** 가능 → 필요 시 오버라이드 가능.

---

## 3. 라이프타임 (Lifetimes)

* **정의**: 참조자가 유효한 범위를 명시하는 방식.
* **목적**: **댕글링 참조(dangling reference)** 방지.
* **기본 규칙**: 대부분의 경우 컴파일러가 자동 추론 (lifetime elision).
* **명시적 표기**:

```rust
// 두 참조 중 더 오래 사는 쪽을 반환
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

* **구조체에 라이프타임 적용**: 참조를 필드로 가질 때 필요.

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

---

## 4. 세 가지 개념의 연결

* **제네릭**: 코드 재사용.
* **트레이트**: 제네릭 타입이 반드시 만족해야 할 동작 정의.
* **라이프타임**: 참조를 안전하게 관리.

예시:

```rust
use std::fmt::Display;

fn longest_with_announcement<'a, T>(
    x: &'a str, 
    y: &'a str, 
    ann: T
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() { x } else { y }
}
```

→ 제네릭(`T`), 트레이트 바운드(`T: Display`), 라이프타임(`'a`)이 함께 사용된 함수.

---

## 10장 정리

* 코드 중복 제거,
* 타입 안정성 유지,
* 안전한 참조 관리

를 동시에 달성하는 방법을 설명하고 있습니다.

