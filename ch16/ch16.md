# 16장: 겁 없는 동시성

Rust는 **소유권과 타입 시스템**을 통해 전통적으로 어려운 **동시성(Concurrency) 문제**를 컴파일 타임에 잡아내도록 설계되었습니다. 이 덕분에 동시성 코드는 안전하면서도 리팩터링하기 쉽습니다.

---

## 1. 스레드 (Threads)

### 기본 사용

* 새로운 스레드 생성: `thread::spawn(|| { ... })`
* 메인 스레드 종료 시, 생성된 스레드도 강제 종료됨.
* 스레드 간 실행 순서는 보장되지 않음 → 경합 조건, 데드락 가능.

### 스레드 제어

* `JoinHandle`을 이용해 스레드 종료를 기다릴 수 있음.

  ```rust
  let handle = thread::spawn(|| {
      for i in 1..10 {
          println!("hi number {} from spawned thread!", i);
      }
  });
  handle.join().unwrap();
  ```
* `move` 클로저: 다른 스레드로 소유권을 안전하게 이동.

---

## 2. 메시지 패싱 (Message Passing)

* **채널(channel)**: `mpsc::channel()` (다중 생산자, 단일 소비자).
* 구조: `tx`(송신자), `rx`(수신자).
* `tx.send(val)` → 다른 스레드에서 `rx.recv()`로 수신.
* `try_recv()` → 블로킹하지 않고 즉시 결과 반환.
* 송신자는 `clone` 가능 → 여러 스레드가 같은 수신자로 메시지 전송 가능.

```rust
let (tx, rx) = mpsc::channel();
thread::spawn(move || {
    tx.send(String::from("hi")).unwrap();
});
println!("Got: {}", rx.recv().unwrap());
```

* **소유권 보장**: `send`가 값을 이동시키므로, 동일 데이터를 동시에 잘못 사용하는 문제 방지.

---

## 3. 공유 상태 동시성 (Shared State Concurrency)

* `Mutex<T>`: 한 번에 하나의 스레드만 접근 가능.

    * `lock()` → `MutexGuard` 반환 (스코프 종료 시 자동 해제).
* 여러 스레드 공유 시:

    * `Arc<T>` (Atomic Reference Counted)와 조합 필요.
    * `Rc<T>`는 스레드 안전하지 않음.
* 예제: 10개의 스레드가 `Arc<Mutex<i32>>`를 공유하여 카운터 증가.

  ```rust
  let counter = Arc::new(Mutex::new(0));
  for _ in 0..10 {
      let c = Arc::clone(&counter);
      thread::spawn(move || {
          let mut num = c.lock().unwrap();
          *num += 1;
      });
  }
  println!("Result: {}", *counter.lock().unwrap()); // 10
  ```
* **유사성**: `RefCell<T>` ↔ `Rc<T>` 와 `Mutex<T>` ↔ `Arc<T>`.
* 주의: `Mutex`는 데드락 가능 → 논리적 버그는 개발자가 예방해야 함.

---

## 4. `Send`와 `Sync` 트레이트

* **`Send`**: 소유권이 스레드 간 이동 가능한 타입.

    * 대부분 타입은 `Send`.
    * `Rc<T>`는 `Send` 아님 (참조 카운트 변경이 스레드 안전하지 않음).
    * 대신 `Arc<T>`는 `Send`.
* **`Sync`**: 여러 스레드에서 동시에 참조 가능한 타입.

    * 예: `Mutex<T>`는 `Sync`.
    * `RefCell<T>`는 `Sync` 아님 (런타임 검사로 스레드 안전 보장 불가).
* 보통 직접 구현하지 않고, Rust가 자동으로 파생.

---

## 핵심 요약

* Rust 동시성은 **소유권/타입 시스템**을 이용해 안전성을 보장.
* **스레드**: `spawn`, `join`, `move` 클로저로 병렬 실행.
* **메시지 패싱**: `mpsc::channel` 기반, 소유권 이동으로 데이터 경합 방지.
* **공유 상태**: `Arc<Mutex<T>>`로 다중 소유 & 안전한 동시 수정.
* **트레이트**: `Send`(소유권 이동), `Sync`(안전한 참조 공유).
