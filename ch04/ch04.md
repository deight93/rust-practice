# 4장: 소유권 이해하기 (Ownership)

---

#### 4.1 소유권이란?

* 러스트의 **메모리 안전성 보장 핵심 개념**
* 가비지 컬렉터(GC) 없이도 메모리를 안전하게 관리
* 기본 규칙:

    1. 모든 값은 **하나의 소유자(owner)** 를 가진다.
    2. 소유자가 스코프를 벗어나면 값은 자동으로 해제(drop)된다.
    3. 동시에 둘 이상의 소유자는 존재할 수 없다.

예시:

```rust
{
    let s = String::from("hello"); // s가 "hello"의 소유자
} // s 스코프 종료 → 메모리 해제
```

---

#### 4.2 이동(Move)과 복사(Copy)

* **이동 (Move)**: 대입 시 소유권이 이전됨

  ```rust
  let s1 = String::from("hello");
  let s2 = s1;  // s1 → 무효, s2가 소유
  ```
* **복사 (Copy)**: 스택에 저장되는 정수형, 부동소수점, 불린, `Copy` trait을 구현한 타입은 값이 그대로 복사됨

  ```rust
  let x = 5;
  let y = x; // x, y 둘 다 사용 가능
  ```

---

#### 4.3 소유권과 함수

* 함수 호출 시 **매개변수 전달 방식**에 따라 소유권 이동 여부가 결정됨

  ```rust
  fn takes_ownership(s: String) {
      println!("{}", s);
  } // s drop됨

  fn makes_copy(x: i32) {
      println!("{}", x);
  } // x 그대로 유지
  ```

---

#### 4.4 반환과 소유권

* 함수에서 값을 반환하면 소유권도 함께 반환됨

  ```rust
  fn gives_ownership() -> String {
      String::from("hello")
  }
  ```

---

#### 4.5 참조(Reference)와 대여(Borrowing)

* **참조(&)**: 소유권을 넘기지 않고 값 사용 가능
* 불변 참조 `&T` (여러 개 가능) / 가변 참조 `&mut T` (동시에 하나만 가능)
* 댕글링 참조(dangling reference) 방지 → 러스트는 항상 안전한 참조만 허용

예시:

```rust
let mut s = String::from("hello");
let r1 = &s;       // 불변 참조
let r2 = &s;       // 불변 참조
let r3 = &mut s;   // ❌ 불변 참조가 존재하므로 가변 참조 불가
```

---

#### 4.6 슬라이스(Slice)

* **컬렉션의 일부를 참조**하는 타입, 소유권 없음
* 문자열 슬라이스 (`&str`):

  ```rust
  let s = String::from("hello world");
  let hello = &s[0..5];   // "hello"
  let world = &s[6..11];  // "world"
  ```
* 배열 슬라이스 (`&[T]`):

  ```rust
  let a = [1, 2, 3, 4, 5];
  let slice = &a[1..3];   // [2, 3]
  ```
* **슬라이스는 원래 데이터와 생명주기를 공유**하므로 인덱스 관리 문제 해결

---

#### 핵심 정리

* 소유권: 데이터의 유효성/해제를 책임지는 메커니즘
* 이동과 복사: 힙 데이터는 Move, 스택 데이터는 Copy
* 참조와 대여: 소유권을 유지하면서 접근 가능, 불변/가변 참조 규칙 존재
* 슬라이스: 안전하게 데이터 일부를 참조할 수 있는 방법
* 러스트는 이를 통해 **컴파일 타임에 메모리 안전성 보장**
