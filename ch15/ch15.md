# 15장: 스마트 포인터

Rust의 **스마트 포인터(smart pointer)** 는 참조(`&`)와 달리 데이터를 **소유**하며, 메타데이터 및 추가 기능을 제공하는 포인터 타입입니다. 대표적으로 `Box<T>`, `Rc<T>`, `RefCell<T>`가 있으며, 이들은 `Deref`, `Drop` 트레이트를 구현합니다.

---

## 1. Box<T> – 힙에 데이터 저장

* **용도**

    * 크기를 알 수 없는 타입을 힙에 저장 (예: 재귀적 타입)
    * 큰 데이터를 복사 없이 이동
    * 트레이트 객체 저장
* **예시**

  ```rust
  let b = Box::new(5);
  println!("b = {}", b);
  ```
* **재귀적 타입**

    * `Box<T>` 덕분에 **Cons List** 같은 자기참조 구조 정의 가능:

      ```rust
      enum List {
          Cons(i32, Box<List>),
          Nil,
      }
      ```

---

## 2. Deref 트레이트

* `*` 연산자 동작을 커스터마이징 → 스마트 포인터를 **참조처럼 사용** 가능.
* `Box<T>`는 자동으로 `Deref` 구현.
* **예시**

  ```rust
  use std::ops::Deref;
  struct MyBox<T>(T);

  impl<T> Deref for MyBox<T> {
      type Target = T;
      fn deref(&self) -> &Self::Target {
          &self.0
      }
  }
  ```
* **역참조 강제 변환 (deref coercion)**
  `&String` → `&str` 자동 변환처럼 함수 인수에서 타입을 암묵적으로 변환.

---

## 3. Drop 트레이트

* 값이 **스코프를 벗어날 때 실행할 코드** 정의.
* `Box<T>`는 자동으로 힙 메모리 해제.
* **예시**

  ```rust
  struct CustomSmartPointer;

  impl Drop for CustomSmartPointer {
      fn drop(&mut self) {
          println!("Dropping!");
      }
  }
  ```
* 강제로 해제: `std::mem::drop(value);`

---

## 4. Rc<T> – 참조 카운트 포인터

* **복수 소유권** 허용. 값의 참조 카운트를 추적하여 0이 되면 메모리 해제.
* 주로 **싱글스레드 공유 데이터**에서 사용.
* **예시**

  ```rust
  use std::rc::Rc;

  let a = Rc::new(5);
  let b = Rc::clone(&a);
  println!("count = {}", Rc::strong_count(&a));
  ```
* `Rc::clone`은 참조 카운트만 증가 (깊은 복사 아님).

---

## 5. RefCell<T> – 내부 가변성

* **불변 참조를 가지고 있어도 내부 값 변경 가능**.
* 규칙 위반은 컴파일 타임이 아니라 **런타임에 panic** 발생.
* 주 용도: **테스트용 목 객체**, API가 불변 참조만 제공할 때 내부 수정 허용.
* **비교**

    * `Box<T>`: 단일 소유권, 컴파일 타임 검사.
    * `Rc<T>`: 복수 소유권, 컴파일 타임 검사.
    * `RefCell<T>`: 단일 소유권, 런타임 검사 (내부 가변성).

---

## 6. 순환 참조와 메모리 누수

* `Rc<T> + RefCell<T>` 조합으로 **순환 참조(cycle)** 발생 가능.
* 순환 시 참조 카운트가 0이 되지 않아 메모리 해제되지 않음.
* **해결책: `Weak<T>`**

    * `Rc::downgrade(&rc)` → `Weak<T>` 반환
    * 소유권 없는 참조 (참조 카운트에 포함되지 않음)
    * 필요 시 `.upgrade()`로 `Option<Rc<T>>` 획득

---

## 핵심 요약

* **Box<T>**: 힙 저장, 재귀적 타입 가능, 트레이트 객체 사용.
* **Deref**: 스마트 포인터를 참조처럼 다룸, `deref coercion` 지원.
* **Drop**: 스코프 종료 시 자원 정리, `std::mem::drop`으로 조기 해제 가능.
* **Rc<T>**: 복수 소유권, 참조 카운트 기반, 싱글스레드용.
* **RefCell<T>**: 런타임 대여 검사, 내부 가변성 제공.
* **Weak<T>**: 순환 참조 방지, 부모-자식 관계 같은 구조에서 활용.
