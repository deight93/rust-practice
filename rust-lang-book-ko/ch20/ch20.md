# 20장: 최종 프로젝트 – 멀티스레드 웹 서버 구축

이 장에서는 지금까지 배운 개념을 종합하여 **TCP 기반의 간단한 HTTP 웹 서버**를 직접 구현합니다.
구현 순서는 다음과 같습니다:

1. TCP/HTTP 개요와 기본 연결 처리
2. 싱글스레드 서버 작성
3. 멀티스레드 서버로 개선 (스레드 풀)
4. 우아한 종료와 정리

---

## 1. 싱글스레드 웹 서버

### TCP 연결 수신

* `TcpListener`로 `127.0.0.1:7878` 포트에서 요청 대기.
* 들어오는 연결(`TcpStream`)마다 메시지 출력.

### 요청 읽기

* `BufReader`로 스트림에서 HTTP 요청 라인/헤더 읽기.
* 첫 번째 요청 라인(`GET / HTTP/1.1`)을 확인하여 요청 구분.

### 응답 보내기

* HTTP 응답 포맷:

  ```
  HTTP/1.1 200 OK\r\n\r\n
  ```
* HTML 파일(`hello.html`)을 읽어서 본문에 추가.
* 특정 경로(`/`)는 성공 응답, 그 외는 `404 Not Found`.

---

## 2. 멀티스레드 서버

### 문제점

* 싱글스레드 서버는 요청을 **순차적으로 처리** → 한 요청이 오래 걸리면 다른 요청 대기.

### 개선: 스레드 풀(Thread Pool)

* 일정 개수의 스레드를 미리 생성해 작업 대기.
* 들어온 요청은 큐에 넣고, 워커 스레드가 가져와 실행.
* 무제한 스레드 생성에 따른 **DoS 공격 위험 방지**.

### 구현 단계

1. `ThreadPool` 구조체 설계 (`new`, `execute` 메서드 제공).
2. `Worker` 구조체: 스레드(`JoinHandle`) 보관, 작업 실행 담당.
3. `channel`(`mpsc`)을 이용해 작업 전달.

    * `execute` → 송신자(`sender`)로 작업 전송.
    * 각 `Worker` → 수신자(`receiver`)에서 작업 받아 실행.
4. 여러 워커가 동시에 접근하므로 `Arc<Mutex<Receiver<Job>>>`로 공유.

---

## 3. 우아한 종료와 정리

### 문제

* `ctrl-c`로 종료하면 워커 스레드가 즉시 종료 → 실행 중인 작업이 중단됨.

### 해결

1. `ThreadPool`에 **`Drop` 트레이트 구현**.

    * `drop` 시 모든 워커 스레드에 종료 신호 전송.
    * 각 워커 스레드의 `join` 호출 → 작업이 끝날 때까지 대기.
2. `Worker` 구조체의 `thread` 필드를 `Option<JoinHandle>`로 변경.

    * `take()`로 꺼내와 `join` 가능.
3. 송신자(`sender`)를 drop → 수신자가 `recv`에서 에러를 감지하고 루프 종료.

### 결과

* 요청이 처리 중일 때도 정상 종료 가능.
* 종료 시 워커들이 순서대로 “shutting down” 메시지 출력.

---

## 핵심 요약

* **싱글스레드 서버**: TCP 연결을 수신하고 HTTP 요청을 읽어 간단한 응답을 반환.
* **멀티스레드 서버**: `ThreadPool` + `Worker` + `channel`로 여러 요청을 동시에 처리.
* **자원 관리**: `Arc<Mutex<_>>`로 안전한 공유, `Drop` 트레이트로 스레드 정리.
* **완성된 서버**: 병렬 처리 가능하며, 종료 시에도 우아하게 정리됨.
