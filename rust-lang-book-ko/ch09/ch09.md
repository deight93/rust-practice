# 9장: 에러 처리 (Error Handling)

러스트는 안전성과 견고함을 위해 에러 처리 방식을 크게 두 가지로 나눕니다: **복구 불가능한 에러**와 **복구 가능한 에러**. 이 장에서는 `panic!`과 `Result<T, E>`를 중심으로 설명합니다.

---

### 9.1 복구 불가능한 에러: `panic!`

* `panic!` 매크로는 프로그램 실행을 즉시 중단시키고 스택을 정리(unwinding)하거나 종료(abort)합니다.
* 주로 **버그나 절대 발생해서는 안 되는 상태**에 사용합니다.
* 예시:

```rust
fn main() {
    panic!("Something went wrong"); // 강제 패닉 발생
}
```

* 벡터 인덱스 범위 초과 시에도 자동으로 `panic!`이 발생합니다:

```rust
fn main() {
    let v = vec![1, 2, 3];
    v[99]; // 존재하지 않는 인덱스 접근 -> panic!
}
```

---

### 9.2 복구 가능한 에러: `Result<T, E>`

* `Result` 열거형은 에러 발생 가능성을 타입 시스템으로 표현합니다.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

* 파일 열기 예시:

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    match f {
        Ok(file) => println!("파일 열기 성공: {:?}", file),
        Err(error) => println!("파일 열기 실패: {:?}", error),
    }
}
```

* `unwrap`과 `expect`:

    * `unwrap()`: `Ok`면 값 반환, `Err`면 패닉
    * `expect("메시지")`: 실패 시 지정한 메시지와 함께 패닉
    * 주로 **프로토타입, 테스트 코드**에서 사용

---

### 9.3 언제 `panic!`이고 언제 `Result`인가?

* **기본 원칙**: 실패할 수 있는 함수는 `Result`를 반환하는 것이 적절
* `panic!`을 선택하는 경우:

    * 예제, 프로토타입, 테스트 코드
    * 개발자가 **절대 실패하지 않음을 확신**하는 경우
    * **계약 위반(불변성 깨짐, 잘못된 상태)** 발생 시
    * 보안상 잘못된 입력이 위험할 때
* `Result`를 선택하는 경우:

    * 잘못된 사용자 입력
    * 네트워크 요청 실패, 파일 없음 등 예측 가능한 오류
    * 호출자가 적절히 처리해야 하는 상황

---

### 9.4 타입으로 상태를 보장하기

* 반복적인 유효성 검사를 피하기 위해 커스텀 타입을 정의할 수 있습니다.

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess 값은 1에서 100 사이여야 합니다. 입력: {}", value);
        }
        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

* `Guess::new`에서만 생성 가능하므로 항상 유효한 값이 보장됨.

---

### 9장 정리

* `panic!` → 복구 불가능한 상태, 즉시 종료
* `Result<T, E>` → 복구 가능한 상태, 호출자가 처리 가능
* `unwrap`, `expect` → 임시/테스트용, 반드시 나중에 처리 코드로 교체
* 타입 시스템을 활용해 **유효 상태를 보장**하는 방식으로 에러를 줄일 수 있음
