# 6장: 열거형과 패턴 매칭 정리

---

## 6.1 열거형 정의하기

* **열거형(Enum)**: 여러 개의 가능한 값(variant)을 가질 수 있는 사용자 정의 타입

* 예제:

  ```rust
  enum IpAddrKind {
      V4,
      V6,
  }
  ```

* 값 생성:

  ```rust
  let four = IpAddrKind::V4;
  let six = IpAddrKind::V6;
  ```

* 열거형은 variant마다 **추가 데이터를 포함**할 수 있음

  ```rust
  enum IpAddr {
      V4(String),
      V6(String),
  }

  let home = IpAddr::V4(String::from("127.0.0.1"));
  let loopback = IpAddr::V6(String::from("::1"));
  ```

* 다른 타입도 포함 가능 (구조체, 튜플, 정수 등):

  ```rust
  enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
  }

  let home = IpAddr::V4(127, 0, 0, 1);
  ```

* 표준 라이브러리의 `Option<T>`도 열거형

  ```rust
  enum Option<T> {
      Some(T),
      None,
  }
  ```

  → 값이 있거나(None) 없음을 안전하게 표현

---

## 6.2 `match`를 이용한 패턴 매칭

* **`match` 표현식**: 값이 어떤 variant인지 확인하고 그에 따라 코드를 실행

  ```rust
  enum Coin {
      Penny,
      Nickel,
      Dime,
      Quarter,
  }

  fn value_in_cents(coin: Coin) -> u8 {
      match coin {
          Coin::Penny => 1,
          Coin::Nickel => 5,
          Coin::Dime => 10,
          Coin::Quarter => 25,
      }
  }
  ```

* 각 분기는 **패턴 → 실행할 코드** 형식

* 모든 경우를 처리해야 함 (포괄적 검사)

* **패턴에 값 바인딩**

  ```rust
  enum Coin {
      Quarter(String), // 주 이름 저장
  }

  match coin {
      Coin::Quarter(state) => println!("State quarter from {state}!"),
      _ => (),
  }
  ```

* `Option<T>`과 함께 쓰는 예:

  ```rust
  fn plus_one(x: Option<i32>) -> Option<i32> {
      match x {
          None => None,
          Some(i) => Some(i + 1),
      }
  }
  ```

* **`_` 패턴**: 사용하지 않는 나머지 경우를 처리할 때 사용

  ```rust
  match dice_roll {
      3 => add_fancy_hat(),
      7 => remove_fancy_hat(),
      _ => reroll(), // 나머지 모든 값
  }
  ```

---

## 6.3 `if let`을 이용한 간결한 제어 흐름

* `match`가 장황할 때 간결하게 표현 가능

* 예:

  ```rust
  let config_max = Some(3u8);

  match config_max {
      Some(max) => println!("The maximum is configured to be {max}"),
      _ => (),
  }

  // 위 코드를 if let으로 간단히
  if let Some(max) = config_max {
      println!("The maximum is configured to be {max}");
  }
  ```

* **`if let` + `else`**

  ```rust
  let coin = Coin::Quarter(String::from("Alaska"));

  if let Coin::Quarter(state) = coin {
      println!("State quarter from {state}!");
  } else {
      println!("Not a quarter");
  }
  ```

* 특징

    * `match` 대비 짧고 가독성 좋음
    * 단점: 모든 경우를 강제하지 않음 → 안전성은 `match`가 더 높음
    * 상황에 따라 선택

---

## 핵심 정리

* 열거형은 여러 상태를 표현하는 강력한 수단
* `Option<T>`는 널(null) 대신 안전한 값 부재 표현
* `match`: 모든 경우를 반드시 처리해야 하므로 안정적
* `if let`: 간단한 한 케이스 매칭에 적합, 보일러플레이트 줄임
* 구조체와 열거형을 함께 사용하면 API를 더 타입 안전하게 설계 가능
