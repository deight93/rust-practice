# 13장: 함수형 기능 – 반복자와 클로저

Rust는 함수형 언어의 영향을 받아 \*\*클로저(Closure)\*\*와 \*\*반복자(Iterator)\*\*를 제공하며, 이 장에서는 이를 활용해 코드의 표현력과 성능을 높이는 방법을 다룹니다.

---

## 1. 클로저 (Closures)

### 정의

* **익명 함수**로, 변수에 저장하거나 다른 함수에 전달 가능.
* 함수와 달리 **정의된 환경의 값**을 캡처할 수 있음.

### 예시

```rust
let expensive_closure = |num: u32| -> u32 {
    println!("Calculating slowly...");
    num + 1
};
```

* 타입 추론 지원: 보통 매개변수/반환 타입 생략 가능.
* 단, 한 번 추론된 타입은 고정됨.

### 캡처 방식

* 불변 참조
* 가변 참조
* 소유권 이동 (`move` 키워드)

```rust
let x = vec![1, 2, 3];
let equal_to_x = move |z| z == x; // x를 클로저로 이동
```

### Fn 트레이트

* `FnOnce`: 한 번만 호출 가능 (소유권 이동 발생 시)
* `FnMut`: 여러 번 호출 가능, 환경 값 수정
* `Fn`: 환경을 수정하지 않고 여러 번 호출 가능

→ 표준 라이브러리 메서드들이 어떤 Fn 트레이트를 요구하는지에 따라 클로저 작성 방식이 달라짐.

---

## 2. 반복자 (Iterators)

### 정의

* **일련의 아이템을 순차적으로 처리**하는 추상화.
* 게으르다 (lazy): 소비 메서드가 호출될 때만 동작.

### Iterator 트레이트

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

### 주요 메서드

* **소비 어댑터** (consume iterator): `sum`, `collect`, `for` loop
* **어댑터** (transform iterator): `map`, `filter`, `zip` 등 → 새로운 반복자 반환, `collect`로 최종 소비.

### 예시

```rust
let v1 = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
```

* 환경 캡처: `filter`에서 외부 변수 캡처 가능.
* 예시: 특정 사이즈 신발만 필터링.

---

## 3. I/O 프로젝트 개선 (12장 리팩터링)

* `Config::build` 함수에서 **반복자 활용** → `clone` 제거.
* `search` 함수 개선:

  ```rust
  contents.lines()
          .filter(|line| line.contains(query))
          .collect()
  ```
* 가변 벡터 제거 → 코드 간결, 병렬화 용이.

---

## 4. 성능 비교

* 루프 vs 반복자 성능 벤치마크 결과:

    * 반복자가 오히려 **약간 더 빠름**.
* 이유: **제로 코스트 추상화 (zero-cost abstraction)** 덕분에 컴파일 시 저수준 코드로 최적화됨.
* 실제 오디오 디코더 예제: `zip`, `map`, `sum` 체인을 사용해도 성능 손실 없음.

---

## 핵심 요약

* **클로저**: 환경 캡처 가능한 익명 함수. `Fn`, `FnMut`, `FnOnce` 세 가지 트레이트로 구분.
* **반복자**: 게으른 시퀀스 처리 추상화. `map`, `filter`, `collect` 등을 활용해 가독성과 유지보수성 향상.
* **I/O 프로젝트 개선**: 반복자와 클로저로 코드 간결화 및 효율성 증대.
* **성능**: 반복자는 루프와 동등하거나 더 빠르며, Rust의 비용 없는 추상화 사례.
