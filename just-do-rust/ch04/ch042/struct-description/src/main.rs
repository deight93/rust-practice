/*
객체지향 언어가 가지는 특성을 보통 "캡추다정상"의 다섯 가지라고 한다. 캡슐화, 추상화, 다형성, 정보은닉, 상속이다
여기서, Rust는 '상속'을 제외하고는 지원한다고 할 수 있다.

* 상속: Rust는 상속을 지원하지 않는다. Rust 설계자들은 기존 Java나 Python에서의
        상속 개념에서 오는 장점보다 단점을 더 크게 본 듯하다.
*/

#[derive(Debug)]
struct Student2 {
    name: String,
    age: u8,
}

fn main() {
    // 구조체의 정의

    // struct 키워드를 사용한다. 그 다음에 '이름'이 나온다. 이름은 첫 글자를 대문자로 쓴다.
    // 그냥 관습이다. 거의 모든 프로그램 언어에서 구조체나 클래스의 이름은 이렇게 첫 글자를 대문자로 한다.
    // 구조체 안에 들어갈 필드들은 블록 기호 { }안에 담는다. 블록 기호 다음에는 ;가 없다.
    // 필드들은 <필드명> : <타입> 형태이고, 필드와 필드 사이는 콤마 ,로 구분한다.

    // Java 프로그래머들은 익숙하겠지만, 객체지향 프로그램에서 클래스와 인스턴스는 다른 거다.
    // 클래스라는 것은 '붕어빵 틀'이고 인스턴스는 '붕어빵'이다.
    // Rust에서도 동일하다. 구조체의 정의는 그냥 클래스의 정의와 동일한 것으로, 붕어빵 틀을 정의한 것이다.
    // 구조체의 인스턴스를 만들어야 실제로 해당 구조체 형태의 데이터 구조가 메모리에 생성되어 사용할 수 있다.
    struct Student {
        name: String,
        age: u8,
    }

    // 1. 구조체 인스턴스의 생성
    // Student라는 구조체의 인스턴스를 만들고, 구조체 내부 데이터에 액세스하는 코드

    // let을 사용해서 구조체 변수를 만들 수 있다.
    // 구조체 변수를 만들면서 동시에 구조체 인스턴스를 만들었다. let s1 = Student { ... };
    // 구조체의 인스턴스를 만들 때는, 구조체에서 정의한 모든 필드에 대해 값을 할당해야 한다.
    // 구조체 인스턴스의 각 필드값을 접근할 때는 <변수명>.<필드명>으로 한다. s1.name
    let s1 = Student {
        name: "Jeff".to_owned(),
        age: 25,
    };

    println!("name: {}, age: {}", s1.name, s1.age);
    // 인스턴스를 만들 때 각 필드에 대한 값을 할당하는 것을
    // <필드명>:<값>처럼 :를 사용했다는 것이 조금 낯설 수 있다. =가 아닌 것에 유의.

    // 2. 쓰기가능 인스턴스 만들기
    // 구조체 인스턴스를 생성한 후, 갱신을 하기 위해서는 mut 키워드를 써야한다.
    // 이때, 구조체의 모든 필드들에 대해 쓰기 가능한 mutable한 상태가 되는 것이고, 일부 필드만 mutable한 할 수 없다.
    let mut s2 = Student2 {
        name: "Jeff".to_owned(),
        age: 25,
    };
    s2.age = 26;

    println!("{:?}", s2);
    println!("name: {}, age: {}", s2.name, s2.age);
    // #[derive(Debug)]를 구조체 정의 앞에 붙이면,
    // 이 구조체에 대해서 println!("{:?}", s1);와 같이 {:?}에 의해서 구조체 전체 필드의 내용을 출력시킬 수 있다.
    // mut를 변수 선언 앞에 붙여서 쓰기 가능한 변수로 만드는 것은, 일반 Rust의 변수 선언 방법과 동일하다.
    // 주의할 것은 mut에 의해서 구조체의 모든 필드가 쓰기 가능하게 되었다는 점.

    // 3. 필드값 편리하게 입력하는 방법들
    let s1 = make_student("Jeff".to_owned(), 25);
    println!("{:?}", s1);
    // let s1 = make_student("Jeff".to_owned(), 25);라고 함수를 호출해서 인스턴스를 만들 수 있다.
    // make_student에서는 주어진 name과 point를 가지고 Student 인스턴스를 만들었다.
    // 리턴할 때는 return 키워드를 안쓰고 이처럼 expression 형태로 놔둬도 함수의 리턴값이 된다.
}

// name과 point를 주면 Student 인스턴스를 만들어서 리턴하는 함수
fn make_student(name: String, age: u8) -> Student2 {
    //     Student {
    //         name: name,
    //         point: point,
    //     }
    Student2 { name, age }
    // 위 함수에서 파라미터로 받은 name과 point가, Student 구조체의 필드명이랑 똑 같다.
    // 이런 경우 아래와 같이 해도 동작한다. 같은 이름을 두 번 적지 않아서 편리하다.
    // Student 인스턴스를 만들 때 name 이라고만 쓰면, name: name과 동일한 효과다.
    // 파라미터의 변수 이름과 구조체의 필드명을 동일하게 해서 쓸 수 있는 기법이다.

    /*
    tip

    개인적으로는 이러한 기법을 쓰는 것에 반대다.
    굳이 name: name이라고 쓰면 될 것을 name이라고 쓰는 것이 그닥 도움이 되지 않는다고 생각하기 때문다.
    많은 예외사항은 오히려 코드를 읽기 힘들 뿐이라고 생각한다.
    그냥 name:naem 혹은 파라미터의 변수 이름이 n이라면 name : n 같은 스타일로 쓰는게 나는 편하다.
    여기서 소개하는 이유는, 이렇게 작성된 코드를 만나더라도 당황하지 말라는 의도일 뿐이다.
    */
}
