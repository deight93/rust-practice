//'트레잇 바운드'
//
// 어떤 함수/메서드에서 제네릭 타입을 파라미터로 받을 때,
// 모든 타입이 아닌 특정 트레잇을 구현(impl)한 타입만 받게끔 하는 것이 '트레잇 바운드'다.

//이처럼 제네릭과 트레잇 바운드 기법을 쓰면, 함수/메서드의 코드는 하나이나 여러 타입에 대해 처리할 수 있게 된다.
// 객체지향 설계에서의 '다형성(Polymorphism)'에 해당. 하나의 코드가 여러 형태의 입력을 처리할 수 있다는 의미

fn main() {
    // 동적 바인딩과 정적 바인딩
    // Java 언어에서는 이러한 다형성을 동적으로 지원한다.
    // 실행 시점에 해당 객체(인스턴스)의 타입에 맞는 메서드를 호출한다. 동적(dynamic)으로 바인딩이 일어난다.

    // 반면, Rust에서는 정적 바인딩을 한다.
    // 컴파일 시점에 해당 객체의 타입이 결정되어 있어야하고 그 타입에 맞는 메서드가 호출되게 바인딩
    // 정적 디스패치(타입에 해당하는 메서드가 호출되도록 하는 것)를 하는 것이다.
    // 따라서, 컴파일 시점에 해당 객체의 타입이 결정되야하고,
    // 그렇기에 '트레잇 바운드'를 통해 수행가능한 타입을 '한정' 해야 한다.

    // 이러한 Rust에서의 '정적 바인딩'은 컴파일 타임 비용을 증가 시킨다.
    // 컴파일 시점에 타입들을 검사하고, 해당 타입에 대한 모든 코드를 컴파일러가 자동으로 구현 해야하기 때문이다.
    // 그러나, 반대로 얘기하면, 이처럼 컴파일 시점에 정적 바인딩을 해 놓기에,
    // 실제 프로그램을 수행하는 시점에는 지연 요소가 없다.
    // '동적 바인딩'을 하는 다른 언어는 실행 시점에 동적 바인딩을 해야하기 때문에 런타임 비용이 발생해서 수행 속도가 느리다.

    /*
    바인딩 vs 디스패치

    '동적 바인딩'과 '동적 디스패치'라는 단어를 혼용해서 쓰고 있는데,
    '바인딩'은 어떤 타입에서 호출하는 메서드 코드를 '결합' 시킨다는 의미에서 사용하는 것이고,
    '디스패치'는 어떤 타입에서 호출하는 메서드가 무엇인지를 결정한다는 의미에서 사용하는 용어다.

    '바인딩'은 컴파일러 혹은 런타임이 '타입'과 '메서드 코드'를 짝 짓는 의미에서 쓰이고,
    '디스패치'는 주로 런타임에서 어떤 코드가 실행될 지를 분기하는 의미에서 쓰인다.

    결국, 여기서 얘기하는 '정적/동적 바인딩'이나 '정적/동적 디스패치' 모두 동일한 표현이다.
     */

    // Rust에서의 정적/동적 바인딩
    // 앞에서 살펴본 '트레잇 바운드',
    // 그리고 이 챕터에서 얘기할 'impl Trait'은 모두 정적 바인딩이다. 컴파일 타임에 바인딩이 일어 난다.
    // 동적 바인딩도 지원한다. Box<dyn Trait>를 통해 가능하다.
    // 이를 사용하면 런타임 비용이 증가한다. 그러나, 꼭 사용할 수 밖에 없는 경우도 있다.
    // 여기서는, 정적 바인딩을 하는 impl Trait과 동적 바인딩을 하는 Box<dyn Trait>에 대해 설명한다.

    println!("Hello, Polymorphism!");
}
