// B. 사용 예: 동적 디스패치

// 적 디스패치는, 프로그램이 수행되는 시점에 어떤 함수나 메서드를 호출할 지 결정하게 하는 기법
/*
다형성과 동적 디스패치

"다형성(Polymorphis)"이라는 것은 '객체지향 프로그래밍'에 나오는 개념으로,
어떤 객체에서 같은 이름을 가진 여러 타입의 메서드가 있을 수 있다는 개념으로 잘 알려져 있다.
이것을 실행 되는 시점에서의 시각으로 보면, 어떤 객체의 aMethod라는 메서드가 수행될 때,
aMethod(String)타입이 사용될 수도, aMethod()가 수행될 수도 있다는 얘기다.
Rust에서는 이러한 '다형성'과 같은 특성을 '동적 디스패치'라는 기법으로 지원하고 있다.
 */

// Rust에서의 '동적 디스패치'는 트레잇(Trait)을 이용해서 구현
// - 트레잇(Trait)은 Java에서의 Interface와 유사한 것으로, 어떤 메서드들을 정의해 놓은 것이다.
// - Rust의 구조체는 트레잇을 '구현(impl)'할 수 있다. 즉, 트레잇에서 정의한 메서드를 자신의 메서드로 '구현'할 수 있다.
// - 예를 들어 ATrait이 있고, 이 트레잇에 a_method()가 정의되어 있을 때, XStructure와 YStructure라는 구조체에서
//    각각 ATrait을 impl하면서 a_method()를 자신의 구조체 성격에 맞게 따로 구현할 수 있다.
// - 이렇게 각자 구현된 상태에서, 어딘가에서 ATrait라는 트레잇의 a_method()를 호출하게 되면,
//   호출될 때 이 ATrait를 impl한 것이 어떤 객체냐에 따라서, XStructure의 a_method()가 호출될지,
//   YStructure의 a_method()가 호출될지 결정된다.
// - 즉, 실행 시점에 어느 객체의 메서드가 호출될지가 결정되는 것이다. 이러한 것이 '동적 디스패치'다.

// Rust에서는 모든 리턴 타입이 컴파일 타임에 결정되야 한다. 만약 타입을 결정할 수 없을 때는 dyn이라는 키워드를 사용해야한다.
// 위 코드에서 트레잇 객체는 컴파일 타임에 그 타입을 결정할 수 없다.
// 해당 트레잇을 구현한 어떤 구조체가 리턴될 지는 실행 타임에 결정되기 때문이다.
// 따라서, dyn Moving과 같이 dyn 키워드를 붙여줘야 한다. 동적 바인딩을 하라는 키워드다.
// 그러나 dyn Moving으로 리턴 타입을 바꿔도 여전히 에러가 뜰 것이다.
// 크기를 한정할 수 없다는 에러

// "크기를 한정할 수 없다는 에러"의 이유는 앞 페이지에서 설명한 것과 같은 이유다.
// 컴파일러가 스택의 크기를 계산할 수 없기에 나오는 에러

// 함수의 리턴 값도 스택을 차지하는 값이다.
// 따라서, find_runner라는 메서드의 리턴 값이 차지하는 스택 크기도 컴파일러가 알 수 있어야 한다.
// find_runner의 리턴 타입은 Moving이다.
// 이 Moving이라는 트레잇 객체는 그 크기를 컴파일 타임에 알 수 없다.
// 왜냐하면, 이 Moving이라는 트레잇을 구현한 객체는 여러 개이고,
// 어떤 객체가 리턴될지는 런타임에 결정되기에, 컴파일 타임에 알 수 없기 때문

// fn find_runner(is_human: bool) -> Box<dyn Moving> {
//     if is_human {
//         Box::new(Human)
//     }else {
//         Box::new(Dog)
//     }
// }

fn main() {
    println!("Hello, world!");
}
