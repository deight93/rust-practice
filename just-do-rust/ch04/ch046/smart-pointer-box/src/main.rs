//Box는 꽤 많이 사용되는 스마트 포인터다.
//
// String과 Vec은 다른 언어에도 비슷한 역할을 하는 것이 있고 해서 스마트 포인트라는 것을 인지하지 않고 그냥 사용한다.
// 그러나 Box는 다른 언어에는 없는 특이한 것이고 Rust의 스마트 포인터 특성을 가장 잘 가지고 있어서,
// 스마트 포인터의 특성을 이해해야만 Box의 동작을 이해할 수 있다.

fn main() {
    // Box의 사용법은 간단하다. Box::new(value)로 Box 객체를 만들고, 이것을 그대로 사용하면 된다.
    let b = Box::new(5);
    // Box 객체를 생성했을 때, 변수 정보는 스택에 위치하게 되고, Box가 가리키는 값은 힙 메모리에 위치하게 된다.
    println!("boxed: {}", b);

    /*
    일반적으로 Box에 대해 설명할 때, 힙에 데이터를 보관하기에, 아주 큰 배열을 사용하려고 할 때 스택 오버플로우가 발생하는데,
    Box를 쓰면 이것을 해결할 수 있다고 한다.
    언듯 생각하기에는 맞는 말 같다. 그러나, 실제 구현을 해보면 스택 오버플로우를 피할 수 없다.
    왜냐면, Box에 큰 배열이 들어갈 때, 스택에 큰 배열이 생성되고 난 후 Box에 들어가기 때문이다.
    아래 코드가 그러한 코드다.

    let box_arr = Box::new([0; 1_000_000_100]);
    // thread 'main' has overflowed its stack
    // fatal runtime error: stack overflow, aborting
    println!("box arr: {:?}", box_arr);
    배열을 구조체로 감싸서 해도 마찬가지로 에러를 피할 수 없다.
    억지로 하려면 벡터로 일단 큰 데이터를 만든 후, 이것을 배열로 바꾸면서 Box에 담는 거다.
    근데, 그럴거면 그냥 벡터를 쓰는게 낫다.

    즉, 필자의 결론은, 큰 데이터는 그냥 벡터를 쓰면된다.
    벡터는 힙 공간을 쓰기에 스택 오버플로우가 나지 않는다. 굳이 Box를 쓸 필요 없다.
    */
}

/*
Box를 써서 유용한 경우는 아래와 같은 경우다.

1. 일반적인 방법으로는 컴파일 타임에 데이터의 크기를 한정할 수 없어 에러가 날 때
2. 특정 트레잇을 구현한 타입을 소유하고자 할 때
3. 큰 크기의 데이터를 실제 복제하지 않고 소유권을 이동시키고자 할 때
 */
