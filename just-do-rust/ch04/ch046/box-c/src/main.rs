// C. 사용 예: 포인터 이동에 의한 복사

// Box의 가장 큰 특징으로 계속 얘기한 것이 "실제 Box가 품고 있는 데이터는 힙 영역에 있고,
// 스택에는 힙 위치를 나타내는 주솟값만 있다" 였다.

fn main() {
    // 그렇다면 아래 코드와 같이, Box 객체에 대해 다른 변수로 '할당(assignment)'을 한다면 어떻게 될까?
    let b1 = Box::new([1, 2, 3, 4]);
    let b2 = b1;
    // let b2 = b1과 같이 b2에 b1을 할당하면, 힙 영역에 있는 데이터는 그대로 있고,
    // 원래 b1이 가지고 있던 해당 힙 영역에 대한 소유권이 b2로 이동하고, b2가 해당 주솟값을 가리키게 된다.
    // 즉, 스택에서의 변화만 일어난다. 따라서, 힙에 있는 데이터의 크기가 아무리 커도
    // 스택에서의 주솟값에 대한 복사만 이루어지기에 금방 복사가 끝난다.
    // 스택 b1 -> 힙 [1], [2, [3, [4]    ----> 스택  b1
    //     b2                                     b2 -> 힙 [1], [2, [3, [4]
    // 위 그림을 보면 Box에 대한 Copy가 금방 수행되는 것이 이해가 된다.
    //
    // 그런데, 만약 위에서 처럼 스택에 있는 Box 객체의 포인터만 이동하는 것이 아니라
    // 힙에 있는 데이터도 복제되길 원한다면 어떻게 하면 될까?
    // 이 때는 clone()을 사용하면 된다.
}

/*
포인터 이동에 의한 쉬운복사가 과연 유용한가?

Box로 선언했을 때, 해당 Box 객체의 복사가 스택에 있는 포인터만 이동하면 되는 간단한 연산이라는 것은 알았다.
그런데, 이런 이유 때문에 굳이 Box를 써야하는가?는 좀 더 생각해봐야 한다.
예를들어 1MB 정도되는 배열이 있다고 하자. 이 배열 변수가 a라고 할 때 let b = a라고 하면
스택에서 1MB 데이터가 전부 복사가 이루어진다. 이것을 Box로 감싸서 복사를 하면 스택 포인터만 이동하는 것이다.
이런 것이 과연 유용해서 굳이 Box를 써야하는가의 문제이다.

필자의 생각은 '굳이'라는 생각이다. 스택에서 1MB 정도의 복사는 금방 일어난다.
따라서, 1회성 복사가 이루어지는 상황에 대해서는 굳이 Box를 사용할 필요는 없다.

단, 복사가 빈번하게 일어나는 경우는 사용할 필요가 있겠다.
그러나, 이러한 경우라도 '배열'이 아니라 Vec를 사용하면 문제가 쉽게 해결될 것이다.
Vec는 Box와 동일한 메카니즘으로 "데이터는 힙에 저장하고, 그 포인터만 스택에 저정'하기 때문에,
벡터(Vec)를 다른 변수에 할당하면 "스택에서의 복사"만 일어나서 연산이 금방 이루어진다.
*/
