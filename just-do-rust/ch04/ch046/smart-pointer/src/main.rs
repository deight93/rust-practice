/*
프로그래밍 언어에서 '포인터'라는 것은 어떤 자료가 저장되어 있는 메모리 주소를 나타내는 것이다.
'포인터 변수'라고 하면 어떤 메모리 주소를 저장하는 변수다.
C나 C++에서는 프로그래머가 이러한 '포인터'를 생성하고 이 포인터를 이용해서 메모리에 대한 연산을 자유롭게 할 수 있다.

그러나, Rust에서는 기본적으로 '포인터' 변수가 없다.
다만 어떤 변수 앞에 &를 붙여서, 해당 변수의 값을 넘겨서 소유권 자체를 넘기는 것이 아닌,
해당 변수의 주소값을 넘겨준다는 의미를 부여한다.
&는 그 주솟값을 '빌린다'는 의미를 가질 뿐 다른 어떤 기능이 있거나 하지 않다.

'스마트 포인터(smart Pointers)'는 어떤 데이터에 대한 주솟값과 함께,
이 주소값을 관리하는 메타 데이터도 같이 가지고 있는 데이터 구조다.
Rust는 몇 개의 '스마트 포인터' 특성을 가지는 데이터 구조를 제공한다.
이를 통해, 데이터가 힙 메모리에 저장되도록 강제화 할 수 있게 하거나(Box),
스택에 있는 다른 두 변수가 같은 힙 공간을 가리킬 수 있다(Rc, Arc).
즉, 일반적인 Rust 기본 규칙으로는 할 수 없는 기능을 수행할 수 있게 한다.

이러한 '스마트 포인터'는 String, Vec, Box, Rc, Arc 등이 있다.

String과 Vec는 이미 앞에서 다룬 데이터 구조다.
String 변수의 경우 힙 공간에 실제 문자열이 저장되고 스택에는 해당 힙 공간을 가리키는 주소와
해당 크기에 해당하는 메타 정보를 가지고 있다. 위에서 얘기한 스마트 포인터의 특성과 일치한다.

벡터(Vec)도 마찬가지다. 실제 데이터는 힙 공간에 위치하게 되고 스택에는
벡터 변수만 저장되며 여기에 힙 메모리 주소와 데이터 크기를 나타내는 메타 정보가 들어 있다.

사실 String과 벡터가 '스마트 포인터'인지 아닌지를 몰라도 String과 벡터를 사용함에 문제 없다.
그러나, Box나 Rc, Arc 등을 이해할 때는 '스마트 포인터'의 특성을 생각해야만 해당 데이터 구조의 동작을 이해할 수 있다.
 */
// ----------------------------------------------------------------------
// 1. 스마트 포인터의 구조
// 스마트 포인터는 데이터가 저장된 메모리 주소와 해당 메모리에 대한 메타 데이터를 가진다. 이러한 정보를 구조체 형태로 갖는다.
// 스마트 포인터의 한 종류인 String의 구조를 보면, 실제 문자열은 힙 메모리에 위치하고,
// 해당 메모리의 주소를 가리키는 값과 메타 정보를 스택에 가지고 있는 구조다.
// 여기서 메타 정보라는 것은 해당 메모리를 관리하기 위한 정보로,
// 여기서는 확보하고 있는 힙 공간 크기를 나타내는 'cap'과 실제 문자열 바이트 크기인 'len'가 메타 정보가 된다.
// cap는 "capaticy"의 약자이고, len은 "length"의 약자다.
// cap은 이 String 변수를 위해 확보하고 있는 메모리 크기를 나타낸다.
// 반면에, len은 이 String 변수가 담고 있는 문자들의 갯수를 나타낸다.
// ----------------------------------------------------------------------
// 2. 스마트 포인터의 동작
// 스마트 포인터의 구조체는 Deref와 Drop 트레잇을 구현한다. 스마트 포인터 구조체의 큰 특징이다.
// Deref는 *x와 같이 스마트 포인터 객체에 *가 붙여 졌을 때의 동작을 정의하는 것이다.
// Drop은 스마트 포인터 객체가 스코프를 벗어날 때 자동으로 수행된다.
// 스마트 포인터 객체가 사용하고 있는 힙 메모리를 해제하기 위함이다.
// 이 Drop에 대해서는 프로그래머가 따로 신경 쓸 것은 별로 없다.
// ----------------------------------------------------------------------
// 3. Deref ( 역참조 )
// Rust에서 일반적인 변수에 대해서 &는 해당 변수의 주소를 참조하라는 기호이고,
// 는 &와 반대로 참조 변수에 대해 역참조 하라는 기호다.
// 예를 들어보면, let b = &a라고 했을 때 b는 a의 주솟값을 가리키는 참조형 변수이고,
// 이 b에 대해 *b를 하게되면 b가 가리키고 있는 주소의 값이기에 a가 된다.
/*
   tip

   *를 붙이면 당연하게 해당 주소의 데이터 값이 나오는게 Rust 기본 문법이기에,
   왜 스마트 포인터가 별도로 Deref 트레잇을 구현해야 *를 붙였을 때 데이터가 나오는지 의문이 들 수도 있겠다.

   일반 변수는 해당 변수의 주솟값 위치에 데이터가 들어 있다.
   그렇기에 &는 해당 위치의 주솟값을, *는 해당 주소의 데이터를 나타내는 형태로 사용할 수 있겠다.

   그러나 스마트 포인터의 경우는, 어떤 변수가 위치한 주솟값에는 스마트 포인터를 나타내는 구조체가 있고,
   이 구조체 안에 실제 데이터를 가리키는 포인터가 있다.
   따라서, 스마트 포인터 변수에 *를 붙힌다고 해서 우리가 원하는 실제 데이터가 나올 수가 없는 것이다.
   따라서, *를 붙였을 때 실제 스마트 포인터가 가리키는 힙 영역의 데이터가 나오게 하기 위해서는 별도 구현을 해야하는 것이다.
*/
// ----------------------------------------------------------------------
// 4. Deref 동작
// 스마트 포인터라고 할 수 있는 String, Vec, Box 등은, 각각 Deref에 대한 동작이 조금씩 다르다.
// 즉, *를 붙였을 때 나오는 값들의 형태가 다르다.
// 이것은 Rust의 표준 라이브러리에 있는 Deref 트레잇이 아래와 같이 정의되어 있기 때문이다.
//
//     pub trait Deref {
//         type Target: ?Sized;   //(1) (2)
//         fn deref(&self) -> &Self::Target;  //(3)
//     }
//
// (1) type Target은 연관 타입이다. 이 트레잇을 구현하는 측에서 이 타입을 결정할 수 있다.
// (2) ?Sized는 Sized 타입일 수도 있고 아닐 수도 있다는 의미다. ? 다음에 타입이 나오는 형태인데,
//      Rust에서 ? 심볼을 사용하는 타입은 Sized 타입이 유일하다.
//      Sized 트레잇을 구현한 것은 모두 해당 타입의 크기를 컴파일 타임에 알 수 있는 것 들이다.
// (3) deref 메서드는 &self 타입에 대해서 &Self::Target을 리턴한다.
//
// deref 메서드에서 무엇을 리턴하는 지가 가장 중요한데, &Self::Target을 리턴한다.
// 즉, Deref 트레잇을 구현한 구조체에서 정한 Target의 참조형을 리턴한다.
// 그래서, 각 스마트 포인터 구조체가 정한 Target이 무엇인지가 중요하다.
//
// ----------------------------------------------------------------------
// 5. String에 대한 Deref
// Stirng에서의 정의는 type Target=str다. 따라서, deref에서의 리턴 타입은 &str이다.
//
//     impl ops::Deref for String {
//         type Target = str;
//
//         #[inline]
//         fn deref(&self) -> &str {
//             self.as_str()
//         }
//     }
// ----------------------------------------------------------------------
// 6. Vec에 대한 Deref
// Vec에서의 정의는 type Target=[T]다. 따라서 리턴되는 것은 &[T]이다.
// 여기서 T는 제네릭 타입이고, 만약 u32 타입의 배열을 원소로하는 벡터이면 &[u32]가 리턴되는 것이다.
//
//     impl<T, A: Allocator> ops::Deref for Vec<T, A> {
//         type Target = [T];
//
//         #[inline]
//         fn deref(&self) -> &[T] {
//             self.as_slice()
//         }
//     }
// ----------------------------------------------------------------------
// 7. Box에 대한 Deref
// Box에서의 정의는 type Target=T다. 따라서 deref에서의 리턴 타입은 &T가 된다.
// 즉, Box에서 감싸고 있는 값에 대한 참조값이 리턴된다.
//
//     impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {
//         type Target = T;
//
//         fn deref(&self) -> &T {
//             &**self
//         }
//     }
// ----------------------------------------------------------------------
// 8. *x에 대한 동작
// Deref 트레잇을 구현한 스마트 포인터 객체에 *을 붙이면 Deref::deref가 동작한다.
// 그리고, Deref::deref에서는 type Target으로 정의한 타입이 리턴
//
// 그런데, *를 붙이면 그냥 Deref::deref가 동작을 하는 것이 아니다.
// 앞에 *가 다시 붙여져서 연산이 이루어진다. 스마트 포인터 객체의 *연산에 대해 Rust가 정한 규칙
//
//     *Deref::deref(&x)
//
// 여기서 x는 스마트 포인터 객체
// ----------------------------------------------------------------------
// String 타입에 대한 *x
// 먼저 String이다.
//
// String의 Deref의 Target은 str이기에, deref에 대한 리턴은 &str이다.
// 따라서, *x = *Deref::deref(&x) = *(&str) = str
// 즉, *x를 하면 str이 나온다.
// ----------------------------------------------------------------------
// Vec 타입에 대한 *x
// Vec의 경우를 알아보자.
//
// Vec의 Deref의 Target은 [T]이기에, deref에 대한 리턴은 &[T]이다.
// 따라서, *x = *Deref::deref(&x) = *(&[T]) = [T]
// 즉, *x를 하면 [T] 가 나온다.
// ----------------------------------------------------------------------
// Box 타입에 대한 *x
// Box의 경우를 알아보자.
//
// Box의 Deref의 Target은 T이기에, deref에 대한 리턴은 &T다.
// 따라서, *x = *Deref::deref(&x) = *(&T) = T
// 즉, *x를 하면 T가 나온다.
// ----------------------------------------------------------------------
//
// 9. 암묵적 "강제 역참조"
// 강제 역참조(Deref coercion) 라는 것은 함수나 메서드의 파라미터로
// 참조형 변수가 전달되면 "강제로 deref가 수행"된다는 것이다.
// 예를들어 아래와 같은 &str을 파라미터로 받은 함수 hello를 만들었다.
// 이것을 호출할 때는 hello("Jeff");라고 하면 된다. "Jeff"의 타입을 &str이기에 hello 함수의 파라미터 정의와 일치한다.
// ----------------------------------------------------------------------

// 10. Vec에 대한 역참조 강제
// Vec의 경우 *x를 하게 되면 [T]가 나온다. 위에서도 알아봤지만 다시 순서대로 왜 [T]가 나온는지 살펴보면,
//
// Vec의 Deref에서의 Target은 [T]다. 따라서 Vec의 deref의 리턴은 &[T]가 된다.
// 왜냐하면, Deref에서 deref 메서드의 리턴값이 &Self::Target으로 정의되어 있기 때문.
// Rust의 역참조 규칙에 의해 *x = *Deref::deref(&x)다. 따라서 x가 Vec 타입이면 *x = [T]가 된다.

fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let s = String::from("hello");
    // let ss = *s; //error
    // error[E0277]: the size for values of type `str` cannot be known at compilation time
    // println!("ss: {}", ss);

    /*
    에러가 왜 나오는지를 해석해 보면, let ss = *s;라고 한 부분에서, *s가 str이 된다. 이것은 위에서 얘기한 * 규칙에 맞다.

    String에 *를 붙이면 str이 나온다고 했다. 그런데, str은 앞 쪽 챕터에서 설명할 때 &str 형태로만 쓰일 수 있다고 했다.

    str은 프로그램 코드 공간에 데이터가 있어서 소유권을 넘겨줄 수 없는 영역에 존재하기에 str 형태로 쓰일 수 없다.
    이처럼 변수의 타입으로 str을 할 수 없다.

    Rust 컴파일러는 이와 같은 "변수 타입으로 str을 쓸 수 없다는는 것을 적용하기 위해서Sized`이용한다.

    Rust에서는 Sized 트레잇을 구현한 구조체만 로컬 변수로 할당할 수 있도록 되어 있다.
    즉, 로컬 변수는 크기를 알 수 있는 형태라야한다는 것이다. 당연한 말이다.

    str은 Sized 트레잇을 구현하지 않는다. 따라서, 위 에러와 같이 size를 알 수 없기에 할당할 수 없다는 에러가 뜬다.
    반면, &str은 Sized 트레잇을 구현하고 있다. 따라서, &str 타입의 변수는 가능하다.
     */

    /*
    tip

    str은 "임의의 크기를 가지는 UTF-8로 인코딩된 문자열에 대한 타입"이다. 힙 공간에 저장되는 문자열을 나타내는 타입인 것이고,
    임의의 크기를 가지는 것이기에 컴파일 타임에 그 크기를 알 수 없다. 따라서, Sized 트레잇을 구현할 수 없다.
    Sized라는 것은 크기를 결정할 수 있어야 구현이 가능하기 때문이다.
    &str은 힙에 있는 문자열의 주소를 가리키는 포인터다. 그 포인터는 스택에 위치하게 되고 두 개의 컴포넌트로 구성된다.

    - 힙에 있는 문자열의 시작 문자가 위치한 주솟값
    - 문자열의 크기

    따라서, &str은 힙에 있는 문자열을 가리키는 "스택에 위치한 레퍼런스"이기에 크기가 고정되어 있다.
    따라서, &str은 Sized 트레잇을 구현하고 있다.
     */

    hello("Jeff");

    let s = String::from("Tom");
    // hello(s); // &str을 원했는데 String 타입을 보냈기 때문 error
    // hello(*s); // *s가 str이기에 hello에서 원하는 &str타입이 아니어서 에러
    hello(&s); // 이것은 동작한다. 여기에 '역참조 강제'가 일어나서 가능한 것
    /*
    이것을 설명하면 이렇다.

    - &s는 &String이기에 hello에서 원하는 &str이 아니다.
      그렇기에 Rust의 '역참조 강제' 규칙에 의해 &String에 대해 역참조 강제가 일어난다.
    - 즉 &(*String)형태가 된다. 여기서 (*String)은 역참조 규칙에 의해 str이다.
    - 따라서 &(*String) = &str이 된다.

    hello(&s)를 한것이 역참조 강제에 의해서 &str타입이 보내진 것과 동일하게 변환이 되어, hello(&s)는 잘 동작한다.
     */
    // ----------------------------------------------------------------------

    let v = vec![1, 2, 3];
    // let vv = *v;    //error
    // error[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time
    // *v는 역참조 규칙에 의해 *Deref::deref(&v) = *(&[i32]) = [i32]가 된다.
    // 여기서 [i32]는 Sized가 구현되지 않은 타입으로 해당 크기를 컴파일 타임에 알 수 없는 타입
    let vv = &v;
    // vv의 타입은 &Vec<i32>가 된다. 여기서 '역참조 강제'가 일어난다고 헷갈리면 안된다.
    // '역참조 강제'는 레퍼런스 타입의 변수가 함수나 메서드의 파라미터로 보내지고,
    // 해당 함수/메서드의 파라미터 타입과 일치하지 않을 경우에만 발생
    print_array(&v);
}

fn print_array(arr: &[i32]) {
    // 역참조 강제가 일어나는 것을 확인하려면 다음과 같은 함수를 만들어서 해보면 되겠다.
    // &[i32]를 파라미터로 받아서 출력하는 print_array라는 함수
    println!("{:?}", arr);
}

/*
요약

스마트 포인터에서는 *에 의해 역참조 될 때, 일반 포인터에 대한 역참조와 유사하게 자신이 품고 있는 데이터 값이 된다.

스마트 포인터 타입 객체 x에 대한 *x의 타입은,

    String의 경우 : str
    Vec<T> 의 경우:  [T]
    Box<T>의 경우: T

스마트 포인터 객체에 대해 참조 형태의 변수가 함수나 메서드의 파라미터로 전달 될 때에는,
해당 함수/메서드에서 요구하는 파라미터 타입과 맞지 않는 경우에 '역참조 강제'가 일어난다.
예를들어 스마트포인터 객체 x에 대해 &x 형태로 어떤 함수/메서드에 보내졌고,
이 타입이 함수/메서드에서 지정한 타입과 다르다면 역참조 강제가 일어나서
 다음과 같은 형태로 변경되서 다시 한번 함수/메서드가 요구되는 파라미터가 되는지 자동 확인된다.

&x에 대해서 각 스마트 포인터 객체별로 '역참조 강제'가 일어나면 아래와 같은 타입으로 변환된다.

    String의 경우:  &x = &(str) = &str
    Vec<T>의 경우:  &x = &([T]) = &[T]
    Box<T>의 경우: &x = &(T) = &T
 */