// A. 사용 예: 컴파일 타임에 크기 한정

// Rust의 컴파일러는 컴파일 시점에 모든 변수에 대한 데이터 크기를 알 수 있어야 한다. 그래야 컴파일 에러를 내지 않는다.
// 어떤 경우에 스택에서 사용되는 변수의 크기를 알 수 없을까?
// 대표적으로 다음과 같은 경우 그 크기를 한정할 수 없다. 재귀적인 데이터 구조일 때이다.

/*
Rust 컴파일러가 스택에 쓰이는 변수크기를 알아야하는 이유

C나 Java로 프로그램을 짠 경우, 프로그램을 동작 시키다가 'Stack Overflow'가 발생하는 경우가 있다.
어떤 함수가 있을 때, 그 함수에 할당된 스택 공간보다 메모리를 더 많이 사용하게되면 이러한 에러가 발생한다.
문제는, 이러한 에러가 프로그램 동작 중에 발생한다는 점이다. 프로그래머가 쉽게 예측하지 못하는 에러다.
Rust는 이러한 문제를 최소화하기위해, 컴파일 타임에 스택에 쓰이는 변수들의 크기를 조사해서
정확한 사이즈의 스택 크기를 각 함수에 할당한다. 이렇게 하기 위해서는 스택에 사용되는 변수의 크기는 '고정'되어 있어야 한다.

그래서, Rust에서는 스택에 쓰이는 변수의 크기를 가늠할 수 없을 때는, 에러를 낸다.
 */

// 1. 재귀적 구조
// [Node] -> [Node] -> [None]
// Node라는 구조체가 있다.
// 한 Node는 다음 Node를 가리킬 수도 있고,
// 가장 마지막 Node는 None을 가리킨다.

// struct Node {
//     // 노드가 있는 경우는 Some(Node)
//     // 없는 경우는, None인 Option을 next_node로 가지는 구조체
//     next_node: Option<Node>,
//     // 24 | struct Node {
//     //    | ^^^^^^^^^^^
//     // ...
//     // 27 |     next_node: Option<Node>,
//     //    |                       ---- recursive without indirection
//     //    |
//     // help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
// }
// // 이 코드를 컴파일 해보면 에러가 뜬다.
// // 재귀적 형태의 구조체 Node가 무한대의 크기를 가진다는 에러다. 그러면서 Box, Rc, &를 사용하라는 가이드가 뜬다.
//
// 1. 왜 Node의 크기가 무한대라면서 에러를 낼까?
//
// Rust 컴파일러는 컴파일 시점에 스택에 저장되는 모든 변수들에 대해서 정확한 크기 혹은 최대 크기를 가늠할 수 있어야 한다.
// 그래야 사용하는 스택 공간에서 충분히 돌릴 수 있는지 아닌지를 판별할 수 있다.
//
// 이제, 컴파일러가 구조체 'Node'의 크기를 어떻게 파악하지 상상해보자.
//
// 구조체는 스택에 저장되는 데이터 구조다.
// Node에는 'next_node'라는 변수 하나만 있기에, 이 변수의 크기를 알아내면 구조체 전체의 크기를 알 수 있겠다.
// 그런데, 'next_node'는 Node를 품고 있는 Option형태의 변수다.
//
// 여기서 문제가 발생한다.
// Node의 크기를 알려고 next_node의 크기를 계산하려는데, 다시 Node의 크기를 알아야한다.
// 무한루프에 빠지는 것이다.
//
// 즉, Node의 크기는 무한대 크기가 되고 만다.
//
// 2. 근데, 왜 Box를 사용하면 해결될까?
// Box를 사용하게 되면, Box가 감싸고 있는 데이터(여기서는 Option<Node>)는 힙에 위치하게 되고,
// 이 데이터를 가리키는 주솟값은 스택에 남게된다.
//
// 이 주솟값의 크기는 usize크기로, 32비트 컴퓨터는 4바이트(=32비트), 64비트 컴퓨터는 8바이트(=64비트)가 된다.
// 즉, 스택을 차지하는 공간의 크기가 결정된다. !!
//
// 컴파일러가 컴파일타임에 알고자하는 것은 '스택'의 크기다. 힙의 크기가 아니다.
// 따라서, Box를 사용하게 되면 스택의 크기가 결정되어 알 수 있기 때문에, 컴파일이 가능하게 되는 것이다.

// 3. Cons List 예
/*
tip
    'Cons List'는 Construct List라는 의미이고, 각 노드에서 "또 다른 List를 가리키는 노드"로 연결하는 구조를 말한다.
    즉, 재귀적 형태의 리스트이다.

    Scala 같은 함수형 프로그램 언어는 재귀적 함수를 쉽게 짤 수 있어서,
    데이터 자료형인 'List'를 구현할 때 'Cons List'를 주로 사용한다.

    제일 마지막에 위치하는 노드의 이름인 'Nil'은, 라틴어의 'nil(아무것도 아님)'에서 유래되었다 한다.
 */
// 콘즈 리스트(Cons List)라고 불리는 자료 구조는 (값, 연결된 리스트)와 같이 재귀적 구조를 가진다.
// [값, 다음주소] -> [값, 다음주소] -> [Nil]
// (값, 연결된 리스트)에서 두 번째 요소인 연결된 리스트가 다른 리스트 전체를 함유하는 재귀적 구조다.
// 콘즈 리스트에서 제일 마지막은 Nil이라고 불리우는 노드로 끝난다.

// 1에서부터 4까지의 값이 연결된 구조를 리스트로 표현
// [1, 다음주소] -> [2, 다음주소] -> [3, 다음주소] -> [NIL]
// 이것을 재귀적 표현법으로 나타내면 다음과 같다.
// Cons(1, Cons(2, Cons(3, Nil)))
//
// 콘즈 리스트를 Rust에서 표현
/*
enum List {
    Cons(i32, List),
    Nil,
}

use List::{Cons, Nil};

fn main(){
    let list =
        Cons(1,
            Cons(2,
                Cons(3,
                    Nil))
        );
}
 */
// 이 코드를 컴파일하면 에러가 뜬다. List의 크기가 무한대라는 에러다.
//
// error[E0072]: recursive type `List` has infinite size
// enum List가 차지하는 최대 크기를 알아내려 노력한다. 그러나 알아낼 수 없다.
//
// 이유는 'Cons(i32, List)'의 크기를 알아낼 수 없기 때문이다. Cons에는 i32와 List가 있다.
// i32는 4바이트이기 때문에 알 수 있고, 문제는 List다.
// List의 최대 크기를 알아내기 위해서 Cons를 조사하는데,
// 다시 List의 크기를 알아내야하기에 무한 루프에 빠지고 만다. 즉, 컴파일러가 크기를 알아낼 방법이 없다.

enum List {
    Cons(i32, Box<List>),
    Nil,
    // List라는 enum을 만들어서, 그 요소로 Cons와 Nil을 가지게하고,
    // Cons는 튜플로 (i32, List)를 가지게 하는 재귀적 방법을 쓰자.
    // 즉, Cons안에 다시 Cons혹은 Nil을 가지는 재귀적 구조
}

struct Node {
    next_node: Option<Box<Node>>,
}

use List::{Cons, Nil};
fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
