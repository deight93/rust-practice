fn main() {
    // F. 구조체에 대한 Copy

    /*
    구조체는 스택에 저장되는 데이터 구조다. 구조체가 가지고 있는 엘러먼트 각각은
    해당 데이터 타입에 따라 스택에 저장되든 힙에 저장되든 하겠지만, 구조체 자체는 스택에 저장된다는 말이다.
    그리고, 구조체는 Copy 트레잇이 구현되어 있지 않다.
    따라서, 구조체에 대해 별도로 Copy 트레잇을 구현하지 않고 =을 사용한 할당을 하면 'move'가 일어난다.

    구조체에 대해서 Copy 트레잇을 구현한다는 것은 구조체 자체에 대해서만 구현하는 것을 말하고,
    구조체가 품고 있는 각 구성원에 대해 구현한다는 것은 아니다. 따라서, 각 구성원들은 이미 Copy 트레잇이 구현되어 있어야 한다.
     */

    // 구조체에 대한 Copy 트레잇 구현이 #[derive(Copy, Clone)]에 의해 가능
    #[derive(Copy, Clone)] // Copy 트레잇은 Clone 트레잇이 이미 구현되어 있어야 가능하다. 같이 속성으로 넣어줘야 함.
    struct Point {
        x: i32, // i32 는 Rust의 원시타입으로 이미 Copy 트레잇이 구현되어 있다.
        y: i32,
    }
    // 위 코드는, 구조체의 각 구성원이 Copy 트레잇이 구현되어 있기에, 구조체 자체에 대한 Copy 트레잇 구현이 가능.

    // 구조체에 대한 Copy 트레잇 구현이 불가하다. 에러가 뜬다.
    // #[derive(Copy, Clone)] //error
    struct Point2 {
        points: Vec<Point>,
    }
    // 구성원이 Vec인데 Vec는 힙 메모리에 데이터가 저장되는 타입으로 Copy 트레잇이 구현되어 있지 않다.
    // 따라서, Vec를 구성원으로 가지고 있는 구조체 PointLIst에 대한 Copy 트레잇 구현 시도는 안된다. 에러가 난다.
}

/*
Summary

할당 연산자 =에 대해서 'move'가 일어나거나 'copy'가 일어나거나 하는 경우에 대해서 알아봤다.
좀 헷갈릴 것이다. 다시 한번 핵심만 요약하면 다음과 같다.

힙 메모리를 사용하는 String, Vec 타입에 대해서는 =에 의해서 'move'가 일어난다.
즉, 스택값은 복사가 일어나서 신규 변수가 생성되고, 힙 데이터는 복사가 일어나지 않고 신규 변수로 소유권 이동만 이루어진다.

String이나 Vec 타입에 대해서 힙 메모리까지 복제가 일어나게 하려면
let s2 = s1.clone()처럼 clone() 메서드를 사용하면 된다.

스택에만 데이터가 있는 원시타입 데이터는 =에 의해 'copy'가 일어난다.
원시타입은 Copy 트레잇이 이미 구현되어 있기 때문이다. 배열도 스택을 사용하는데 역시 =에 의해서 'copy'가 일어난다.
따라서, 좀 큰 데이터이고 할당이 빈번하게 벌어진다면 해당 데이터를 배열이 아니라 Vec로 선언하는게 좋다.
Vec의 경우 스택 정보만 복사되기에 연산 속도가 빠르기 때문이다.

구조체는 디폴트로 Copy 트레잇이 구현되어 있지 않기에, 구조체에 대해 =을 사용하면 'move'가 일어난다.
구조체에 대해 Copy 트레잇을 구현하려면, 품고 있는 구성원이 모두 이미 Copy 트레잇이 구현되어 있어야 한다.


할당 연산자에 대해 move인지 copy인지 복잡해서 헷갈린다면 다음과 같이 해도 된다.
"스택만 사용하는 타입은 copy, 힙을 사용하는 타입은 move"라고 일단 알아 두자.

실제 코딩하다가 컴파일러에서 소유권 이동해서 사용할 수 없다는 에러가 나면,
move가 발생했다는 것을 인지하고 copy 혹은 clone이 될 수 있도록 하면된다.

기본은 move, Copy면 복사, 힙 소유 타입은 거의 move
 */
