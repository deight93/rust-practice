fn main() {
    /*
    소유권 개념

    1. 메모리에 대해서 '소유권'이란 개념을 둔다.
    2. 어떤 시점에서, 어떤 메모리 영역에 대해 오직 하나의 변수만이 '소유권'을 가질 수 있다.
    3. 해당 변수가 `생존 스코프`를 벗어날 때, 해당 변수가 소유하고 있는 메모리를 같이 해제한다.
    */

    // 메모리에 대해서 '소유권'이란 개념을 둔다.
    //  -> 어떤 메모리 영역을 가리키는 변수를 해당 메모리 영역을 '소유'하고 있다고 보는 것

    // 어떤 시점에서, 어떤 메모리 영역에 대해 오직 하나의 변수만이 '소유권'을 가질 수 있다.
    //  -> 어떤 메모리 영역에 대해서는 다른 변수를 지정할 수 없다는 말

    // 예시 ------------------------------------------------------------
    let a = vec![1, 2, 3]; // 벡터 힙 소유권 a
    println!("a = {:?}", a);

    let b = a; // 소유권 이동 a -> b
    println!("b = {:?}", b);
    // println!("a = {:?}", a); // error // 소유권 이동되어 a는 유효한 변수가 아님.

    //  a라는 변수에 벡터를 할당하고, 이것을 b라는 변수에도 할당한 것. 그러고 나서 변수 a와 b의 내용을 확인
    // Rust의 '소유권' 개념에 따라 변수 a에게 벡터가 저장된 공간에 대한 소유권이 있다.
    // 그런 상태에서 'b'라는 변수도 해당 메모리를 가리키게 한 것인데,
    // 이는 하나의 메모리는 오직 하나의 변수만 소유권을 가져야한다는 것을 위반함.

    // 하나의 메모리 공간은 하나의 변수만이 소유권을 가져야하기에,
    // 컴파일러는 위 코드의 let b = a; 시점에 a가 가리키고 있던 메모리에 대한 소유권을 변수 b로 이동시킨다.
    // 따라서, 변수 a는 더이상 소유권을 가지지 못하고, a는 더 이상 유효한 변수가 아니다.
    // 이러한 변수 a의 내용을 프린트하려고 하면 컴파일러가 알아채고 에러를 출력한다. 컴파일이 안된다.
    // -------------------------------------------------------------------

    /*
    tip

    위에서 "어떤 시점에서, 어떤 메모리 영역에 대해 오직 하나의 변수만이 '소유권'을 가질 수 있다."라고 했다.
    Rust에서 이것이 100% 지켜지는 것일까?
    예외가 존재하는데, Rc와 Arc객체가 그렇다. 이 객체들은 힙에 위치하게 되는데, 여러 변수가 동일한 Rc 객체를 가리킬 수 있다.
    그런 목적으로 만들어진 객체이기 때문이다. 따라서, 위에서 얘기한 원칙은 사실 이렇게 얘기해야 맞겠다.
    "일반적으로 어떤 시점에서, 어떤 메모리에 대해 오직 하나의 변수만이 '소유권'을 가질 수 있다.
    예외인 객체가 있는데 Rc와 Arc가 그렇다."
     */

    // 예시2 ------------------------------------------------------------
    // "Hello Jeff"라는 값은 힙에 저장되고, s라는 변수정보는 스택에 생기면서
    // "Hello Jeff" 값이 들어 있는 힙 주소를 가리키게 됨
    let s: String = String::from("hello jeff"); // String을 생성하고 변수 s에 할당

    // 문제는 let point = cal_point(s);에서 s를 cal_point라는 함수로 넘긴데서 발생
    // 이렇게 하면 cal_point 함수의 파라미터 변수인 w는 스택에 그 정보를 생성하게 되고,
    // 이 w 변수가 "Hello Jeff"라는 힙 영역을 가리키게 된다.
    // 즉, "Hello Jeff"의 힙 영역은 변수 s에서 변수 w로 그 소유권이 이동한다.
    let point = cal_point(s); // s -> w 소유권이 이동

    // println!("s = {}", s); // error 아무 소유권도 없는 빈털털이 ㅠㅠ
    println!("point = {}", point);

    // **** Rust에서는, 메모리에 대해서 오직 한 개 변수만이 소유권을 가지게 한다는 것 ****

    /*
    그럼 이렇게 한 개 변수만이 소유권을 가지게 해서 뭘 하자는 걸까? 무엇이 좋아진 것일까?

    이렇게 함으로써, `어떤 변수가 그 수명을 다할 때` 그 변수가 소유하고 있는 메모리를 해제할 수 있다는 것이다.
     */

    // 예시3 ------------------------------------------------------------
    let a = 1;
    sub_fn(); // b, c 변수

    // assert_eq!(10, b); // error 변수의 수명이 다 되었는데도 접근하려고 할 때 에러
    assert_eq!(1, a)

    // main 함수에서는 변수 a만 선언되어 있다.
    // 이 변수는 선언될 때 스택에 생성이되고 (기본 타입인 i32 타입이기에 그냥 스택에 변수 정보 및 값이 저장된다. )
    // main 함수가 끝날 때 변수 a의 수명이 종료된다.
    // main 함수에서 sub_fn이 호출되고 sub_fn안에서 변수 b와 c가 선언되었으나,
    // 이 변수들은 모두 sub_fn이 종료될 때 해제되었기에, main함수에서 변수 b를 사용하려면 안된다.

    /*
    이 처럼 변수의 수명은 해당 스코프를 벗어날 때 끝나고, 컴파일 타임에 각 변수들의 수명을 알 수 있다.
    이는 힙을 사용하는 변수도 마찬가지다. 위 코드에서 힙 메모리를 사용하는 변수는 변수 c다.
    변수에 대한 정보는 스택에 저장되고 실제 값은 힙에 저장된다.

    이와 같이 변수들이 자신의 스코프를 벗어날 때, 만약 힙을 가리키고 있는 변수라면,
    해당 변수가 소유하고 있는 힙 메모리를 해제해도 되는 것이다.
    `해당 메모리는 유일하게 하나의 변수만이 소유하고 있다는 것이 보장되기에
    힙 메모리를 해제해도 문제가 없게 되는 것이다. !!`

    * tip
    Rust 컴파일러는 해당 변수가 종료될 때 drop()이라는 함수를 자동 호출하게해서
    해당 변수가 소유하고 있는 힙 메모리가 해제되게 한다.
    */

    // ------------------------------------------------------

    /*
    근데, 여기서 좀 문제가 있다.
    위에서 소유권 이전이 일어나면서 에러가 났던 코드를 본 게 있는데,
    변수를 어떤 함수의 파라미터로 보냈더니 소유권 이동이 일어났고,
    함수 호출 이후에는 해당 변수를 사용하지 못하는 문제가 있었다.

    그럼 어떻게 하란 얘긴가? 함수로 변수를 보내고 난 후에는 다시는 그 변수를 사용하지 못하면,
    그 변수를 다시 사용해서 뭔가를 해야하는 경우는 어떻게 해야하나?

    Rust에서는, 이러한 문제를 해결하기 위해서 `대여`라는 방법을 제공
    */

    /*
    대여가 유일한 방법인가?

    대여를 안하고, 해당 메모리 영역을 복사해서 한 벌 더 만들어서 사용할 수도 있다.
    실제로 Rust에서의 원시 타입인 i32, f32 등은 할당 연산이 일어날 때 자동으로
    해당 데이터가 한 벌 더 복사되서 새로운 변수에 할당되어 사용된다.
    따라서 소유권 이동에 의해서 처음 변수가 사용되지 못하는 문제가 발생하지 않는다.
    즉, 위에서 얘기한 새로운 변수로의 할당 그리고 함수의 파라미터로
    보냄에 의한 소유권 이동문제는 대부분 '힙' 메모리를 사용하는 데이터인 'Vec' 'String' 등에서 나오는 문제이다.

    이 부분은 이 챕터의 `Copy vs. Clone` 부분에서 좀 더 다룬다.
     */
}

fn cal_point(w: String) -> i32 {
    // 주어진 String에 대해서, 모두 대문자로 바꾸고 'A'=1, 'B'=2 순서로 점수를 메겨서,
    // 전체 알파벳에 대한 점수를 메긴 후 합계를 구하는 함수
    w.to_uppercase()
        .bytes()
        .filter(|c| (*c >= b'A') && (*c <= b'Z'))
        .map(|c| (c - b'A') as i32)
        .sum()
}

fn sub_fn() {
    let b: i32 = 10; // sub_fn에서 선언된 변수 b는 sub_fn이 종료될 때까지 그 수명이 유지
    assert_eq!(10, b);

    {
        assert_eq!(10, b);
        let c: Vec<i32> = vec![1, 2, 3]; // 변수 c는 중괄호 영역에서 선언, 영역이 끝나면 더 이상 존재하지 않는다.
        assert_eq!(vec![1, 2, 3], c);
    }
    // 영역 밖에서 c를 사용하려면 에러가 발생
    // assert_eq!(vec![1, 2, 3], c); // error 변수의 수명이 다 되었는데도 접근하려고 할 때 에러
    assert_eq!(10, b);
}
