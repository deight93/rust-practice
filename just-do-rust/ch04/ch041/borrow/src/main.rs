fn main() {
    // 메모리에 대해서 하나의 변수만이 소유권을 가짐에 따라 생기는 문제를 '대여'를 통해 해결

    /*
    대여의 개념

    1. 한 변수가 가진 메모리에 대한 소유권을 다른 변수에 '대여'할 수 있다.
    2. '읽기 대여'는 여러 변수에 할 수 있다.
    3. '쓰기 대여'는 일종의 '임시 이동'이고 이 임시 이동 기간에 다른 '읽기 대여 변수' 혹은 '소유권 변수'에 접근할 수 없다.
    4. 대여 받은 변수가 종료될 때는 대여 받은 메모리에 대한 해제를 하지 않는다.
    5. 해당 메모리에 대한 대여가 종료된 후라야 해당 메모리에 대한 해제를 할 수 있다.
    */

    /*
    1. 한 변수가 가진 메모리에 대한 소유권을 다른 변수에 '대여'할 수 있다.
    하나의 변수만이 어떤 메모리 영역에 대한 '소유권'을 가진다는 데는 변함이 없다.
    다만, 다른 변수가 해당 영역을 액세스는 할 수 있게 하는 것이다. 소유권은 원래의 변수가 가진 채로.
    이렇게 하면 뭐가 좋은 것인가?

    해당 메모리를 대여 받은 변수가 액세스해서 뭔가 할 수 있게 되는 것이다.
    그리고, 이 대여 변수가 종료될 때 그 대여권이 반환된다.
    그러고 나서, 원래의 소유권을 가진 변수가 종료될 때만이 해당 메모리가 해제된다. 깔끔하다. 문제가 없다.
     */

    // 예시1 ------------------------------------------------------------
    let a = vec![1, 2, 3, 4, 5]; // 변수 a는 벡터 타입으로 힙 데이터를 사용. 소유권 갖는다.
    println!("{:?}", a);

    // 변수 a를 get_even_cnt에 파라미터로 보낸다. 이때 소유권 이동이 일어나지 않게 &a와 같이 해서 넘긴다.
    // 그냥 a라고 하면 변수 a가 복제되어 함수로 전달되는 것이고 해당 힙 영역에 대한 소유권도 이동된다.
    // 그러나 &a라고 하면 변수 a에 대한 주소(레퍼런스)를 넘기는 거고,
    // 이렇게 레퍼런스로 넘기면 해당 힙에 대한 소유권이 아니라 '대여'만 되는 것
    // get_even_cnt에 있는 파라미터 변수 x는 힙 메모리에 대한 대여권을 가지고 있기에, 해당 힙 영역을 읽을 수 있다.
    // main 함수에서 get_even_cnt를 호출하고 난 후에도 변수 a가
    // 자신의 힙 공간에 대한 소유권을 가지고 있기에 println!("a={:?}",a);와 같이 여전히 a를 사용할 수 있다.
    let cnt = get_even_count(&a); // a의 주소만 넘김
    println!("{:?}", cnt);
    println!("{:?}", a); // 소유권 a가 힙메모리 가지고 있음.
    // ------------------------------------------------------------

    // 예시2 ------------------------------------------------------------
    // 대여 받은 공간에 '쓰기'도 가능할까? 가능하다. 대신 쓰기 가능한 대여권을 줘야한다.
    // &mut a와 같이 변수명 앞에 &mut를 붙여줘야 한다. mutuable한 대여권을 준다는 의미
    let mut b = vec![1, 2, 3, 4, 5];
    println!("{:?}", b);

    add_one(&mut b); // 쓰기가능한 대여권 부여
    println!("{:?}", b);
    // 이렇게 되면, add_one내에서 해당 벡터의 내용을 바꿀 수 있다. 힙 내용을 바꿀 수 있다는 얘기다.
    // 따라서, add_one 함수가 종료된 후에, main 함수에서 이 힙에 대한 소유권을 가지고 있는
    // 변수 a의 내용을 출력하면 바뀐 내용으로 값이 출력된다.
    // 원래 [1,2,3,4,5]이 었는데 add_one에서 1씩 증가했기에 [2,3,4,5,6]로 출력된다.
    // ------------------------------------------------------------

    // 2.'읽기 대여'는 여러 변수에 할 수 있다.
    // 예시3 ------------------------------------------------------------
    let a = vec![1, 2, 3, 4, 5];
    println!("예시3");
    println!("{:?}", a);

    let b = &a; //대여 1회차
    println!("{:?}", b);
    println!("{:?}", a);

    let c = &a; //대여 2회차
    let d: Vec<i32> = c.into_iter().map(|x| *x + 1).collect();
    println!("{:?}", d);

    let cnt = get_even_count(&a); //대여 3회차
    println!("{:?}", cnt);

    println!("{:?}", a);
    println!("{:?}", b);
    println!("{:?}", c);
    println!("{:?}", d);

    // 대여를 3회 했는데 모두 문제 없다. 단, 모두 읽기 전용 대여다.
    // ------------------------------------------------------------

    // 3.'쓰기 대여'는 일종의 '임시 이동'이고 이 임시 이동 기간에 다른 '읽기 대여 변수' 혹은 '소유권 변수'에 접근할 수 없다.
    // 예시4 ------------------------------------------------------------
    let mut x = vec![1, 2, 3, 4, 5];
    let rx = &x;
    let wx = &mut x;

    // 아래 예제를 보자. 벡터에 대한 소유권을 가진 변수 x가 선언되었고,
    // 이것에 대해 읽기 전용 대여를 한 rx와 쓰기 가능 대여를 한 wx를 선언했다.
    // 컴파일 해보면 "변수를 선언만하고 사용하지 않고 있다"는 warning은 뜨지만, 에러가 발생하진 않는다.

    //1. 소유권 변수 x
    let mut y = vec![1, 2, 3, 4, 5];
    println!("{:?}", y);

    //2. 읽기 대여
    let rx = &y;
    println!("{:?}", rx);

    //3. 쓰기 대여
    // 여기서 조심할 것은 '쓰기 대여 구간'안에서 원래 소유권을 보유한 변수인 x,
    // 혹은 읽기 대여를 받은 변수 rx에 접근하려고 하면, 에러가 발생한다.
    let wx = &mut y;
    // println!("y={:?}", y); //에러 발생
    // println!("rx={:?}", rx); //읽기 대여한 변수 접근에도 에러 발생
    wx[0] = 100;
    println!("{:?}", wx);
    println!("{:?}", y);

    /*
    쓰기 대여는 일종의 '임시 이동'이 발생한 상태로 봐야한다. let wx = &mut x;에 의해 쓰기 대여가 발생했고,
    println!("wx={:?}",wx); 코드 있는 데 까지가 쓰기 대여된 구간이다.
    이 구간 사이에 println!("y={:?}",y);이라는 코드가 들어가 있는데, 이는 원래 소유권을 가지고 있는 변수 y에 대한 접근이다.
    이러한 접근을 Rust는 허용하지 않는다. 아래와 같은 컴파일 에러가 발생한다.
     */

    // 읽기 대여중에 다른 읽기 대여 중인 변수를 액세스하는 것은 문제 없다.
    // 다만 쓰기 대여 구간 사이에, 같은 메모리 공간을 바라보는 원래의 소유권 변수 혹은 읽기 대여 변수에 접근하려면 에러 발생

    // 이는 공유 자원을 접근할 때 발생하는 '레이스 컨디션(Race condition)'
    // 문제를 방지하기 위해서 Rust에서 선택한 방법이다.
    // '쓰기 구간'에는 해당 메모리를 참조하는 다른 변수들에 대한 액세스가 허용되지 않는다.

    // ------------------------------------------------------------

    // 예시5 ------------------------------------------------------------
    // '읽기 대여 구간'에 동일한 메모리에 대해 '쓰기'가 발생했다. 이것도 역시 에러가 발생한다.
    // 소유권 변수 x
    let mut x = vec![1, 2, 3, 4, 5];
    println!("{:?}", x);

    // 읽기 대여
    let rx = &x;
    // x[0] = 100; // //에러: '읽기 대여' 도중에 쓰기 수행
    println!("{:?}", rx);
    // ------------------------------------------------------------

    // 정리하면,
    // * '쓰기 대여 구간'에 동일한 메모리에 대한 참조 변수를 액세스할 수 없다.
    // * '읽기 대여 구간'에 동일한 메모리에 대해 쓰기 작업을 할 수 없다.

    // 예시6 ------------------------------------------------------------
    /*
    tip

    '쓰기 구간'에, 해당 메모리에 대한 다른 참조자들에 대한 액세스가 안되게 하는 것은,
    힙 메모리 변수에만 해당하는 제약조건이 아니다. 스택 변수도 이 제약조건이 해당된다.
    아래 코드에서 변수 x는 i32타입으로 스택 변수이다. 이처럼 스택변수에 대해서도
    '읽기 대여'를 하는 동안에, 해당 변수를 '쓰기' 할 수 없다.
     */

    //1. 소유권 변수 x
    let mut x = 10;
    println!("x={:?}", x);

    //2. 읽기 대여
    let rx = &x;
    // x = 4;  //에러: '읽기 대여' 도중에 쓰기 수행

    println!("rx={:?}", rx);
    // ------------------------------------------------------------

    // 4.대여 받은 변수가 종료될 때는 대여 받은 힙 메모리에 대한 해제를 하지 않는다.

    // 당연한 말이다. 대여받은 변수는 해당 힙 메모리에 대한 소유권이 있지는 않기에,
    // 대여 받은 변수가 종료되었다고 해서 메모리를 해제하면 안된다.

    // 예시7 ------------------------------------------------------------
    let a = vec![1, 2, 3, 4, 5];
    let cnt = get_even_cnt2(&a);
    println!("{:?}", cnt);
    println!("{:?}", a);

    // get_even_cnt(&a)에서 변수 a에 대한 참조자 형태로 함수에 전달되었다. 즉, 대여가 발생했다.
    // get_even_cnt함수가 종료되면 파라미터 변수 x도 종료된다.
    // 그렇더라도, 변수 x가 대여받은 힙 메모리를 해제하진 않는다.
    // 따라서, get_even_cnt함수가 호출되고 난 후에도
    // println!("a={:?}",a);처럼 해당 힙 메모리의 내용에 액세스할 수 있는 것이다.
    // ------------------------------------------------------------

    // 5.해당 메모리에 대한 대여가 종료된 후라야 해당 메모리에 대한 해제를 할 수 있다.
    // 예시8 ------------------------------------------------------------
    /*
    이 말은 어떤 메모리를 참조하는 변수가 있는 경우, 해당 메모리를 해제할 수 없다는 말이다.
    만약 어떤 변수가 사용되지 않는 메모리를 가리키고 있다면 큰 문제다.
    이러한 것을 '댕글링 포인터 (Dangling Point)' 문제라고 하는데,
    Rust에서는 이러한 문제가 발생하지 않도록 컴파일 타임에 체크한다.
    */

    let x: &String;

    // {
    //     let s = String::from("hello");
    //     x = &s; //  x는 댕글링 포인터
    // }
    // println!("x={}", x);

    /*
    블럭 안에서 String이 선언되었고, 이 String을 변수 x가 참조하고 있다. 즉, 대여를 받았다. x=&s
    이 상태에서, 블럭이 끝나면 변수 s는 종료되고 s가 소유하고 있는 힙 메모리도 해제된다.
    그렇게 되면, 블럭 밖에서도 생존하고 있는 변수 x는 댕글링 포인터가 되어 버린다. 의미없는 메모리 공간을 가리키게되는 것이다.
    따라서, Rust에서는 이런 경우 컴파일 에러를 낸다. 어떤 힙 공간을 참조하고 있는 변수가 있으면,
    즉 어떤 힙 공간을 대여한 변수가 있으면, 해당 힙 공간을 해제할 수 없다.
    */

    let x: &String;

    let s = String::from("hello");
    x = &s;

    println!("x={}", x);
    // ------------------------------------------------------------

    /*
    Rust는 이러한 개념을 적용함으로써 어떤 변수가 종료될 때 해당 메모리를 같이 해제 할 수 있게 되었다.
    프로그래머가 직접 메모리 해제를 하지 않고 프로그램에서 자동 해제된다.

    그러나, 이런 잇점의 이면에는 힙 변수를 사용할 때의 불편함이 있다.
    잘못 사용하면 컴파일 에러가 나고, 이것을 고치는 것은 프로그래머의 몫이다.
    (물론 Rust의 컴파일러는 C나 Java에 비해 좀 더 상세하게 에러가 나온 부분과 어떻게 고칠지를 알려주지만.)

    따라서, 우리가 중요하게 알아야할 것은 어떻게 Rust의 '소유권'과 '대여' 개념에 어긋나지 않게 프로그래밍 하느냐이다.
    '소유권'과 '대여' 설명 페이지에서 다룬 개념도 잘 알아야겠지만, '소유권'과 '대여' 관련한 실제 코드를 짜면서,
     발생한 에러에 대해 잘 고칠 수 있게 훈련하는 것이 중요
    */
}

fn get_even_count(x: &Vec<i32>) -> i32 {
    let mut count = 0;
    for i in x {
        if i % 2 == 0 {
            count += 1;
        }
    }
    count
}

fn get_even_cnt2(x: &Vec<i32>) -> usize {
    // get_even_cnt함수에 대해, 이 글의 위 쪽편에서 이 함수를 짤 때는 for 루프를 이용한 고전적인 방법으로 짰는데,
    // 여기서는 반복자 어댑터를 사용해서 코딩했다. 수행하는 것은 똑 같다.
    // 단지 반복자 어댑터가 코드가 좀 더 간결하다. 간단한 코드는 반복자 어댑터를 사용하는게 편하고 코드가 더 간결해진다.
    x.into_iter().filter(|x| **x % 2 == 0).count()
}

fn add_one(x: &mut Vec<i32>) {
    // 함수 add_one을 호출할 때 &mut a를 사용했다.
    // 변수 a에 대해서 mutalbe한 레퍼런스를 넘긴다는 의미다. 즉, 쓰기 가능한 대여권을 부여한 것이다.
    // add_one 함수의 파라미터 선언에서도 &mut Vec<i32>라고해서, mutable한 벡터 레퍼런스를 받는다고 명시해야 한다.
    x.iter_mut().for_each(|i| *i += 1);
}
