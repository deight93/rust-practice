use std::collections::HashMap;

fn main() {
    // ---------------------------------------------------------------------------------
    // 예제 1. 반복자를 생성할 때 소유권 이동이 일어나는 경우
    // 1~100까지의 벡터 a에 대해서, 짝수만을 필터링해서 새로운 벡터 b에 저장하고, 두 벡터 크기를 출력하는 코드

    let a = (1..101).collect::<Vec<i32>>();
    // let b = a.into_iter().filter(|&x| x % 2 == 0).collect::<Vec<i32>>();
    // println!("a.len() = {}, b.len() = {}", a.len(), b.len()); // error

    // error[E0502]: cannot borrow `a` as mutable because it is also borrowed as immutable
    // into_iter()는 소유권을 가져오면서 반복자를 생성하는 메서드
    // 위 코드에서 a.into_iter()에 의해 a는 소유권을 잃는다. 그런 상태에서 a.len()을 하려니 에러가 발생하는 것

    // 해법은, 소유권 이동이 일어나는 것이 아닌 "대여를 통해" 반복자를 생성하는 iter() 메서드를 사용
    let b = a.iter().filter(|x| **x % 2 == 0).collect::<Vec<&i32>>();
    println!("a.len() = {}, b.len() = {}", a.len(), b.len());
    // iter()메서드는 벡터에의 접근을 레퍼런스로 한다. 즉, 대여를 받는다.
    // 그렇기에 &가 붙은 레퍼런스 형태로 벡터의 원소에 접근하게된다. 따라서,
    // 해당 원소의 값을 접근할 때는 **i와 같이 de-referencing 해야 한다.

    // 또 다른 해법은 벡터 a를 복제( clone() )해서 사용하는 것이다. 굳이 into_iter()를 쓰고자 하는 경우이다.
    let b = a
        .clone()
        .into_iter()
        .filter(|&x| x % 2 == 0)
        .collect::<Vec<i32>>();
    println!("a.len() = {}, b.len() = {}", a.len(), b.len());
    // ---------------------------------------------------------------------------------

    // ---------------------------------------------------------------------------------
    // 예제 2. for 루프에서의 쓰기 작업
    // 벡터에 있는 각 숫자에 10을 더한 숫자로 갱신
    // for ~ in을 사용해서 갱신하려고 하는데 에러가 발생하고 있다. 에러가 안나오게 수정
    let mut v = vec![3, 4, 5, 6, 7];

    // for i in v {
    //     i += 10;
    // }
    // 쓰기 가능한 대여를 해서 사용해야한다.
    // 즉, 벡터 v에 대해 mutable한 reference 타입 처리를 해줘야 한다. for i in &mut v
    // 여기서 i는 레퍼런스 타입이기에, 실제 값에 접근하기 위해서는 *를 붙여 줘야 하겠다.
    for i in &mut v {
        *i += 10;
    }
    println!("{:?}", v);
    // ---------------------------------------------------------------------------------

    // ---------------------------------------------------------------------------------
    // 3. mutuable한 반복자
    // 벡터의 모든 값을 갱신하기 위해 for ~ in을 사용했다. 이것을 반복자를 사용하여 동일한 결과가 나오도록 구현
    let mut v = vec![3, 4, 5, 6, 7];
    v.iter_mut().for_each(|i| *i += 10); // iter_mut()를 사용

    println!("{:?}", v);
    /*
    벡터 같은 컬렉션에서 반복자를 생성하는 메서드는 크게 3가지

    - into_iter() : 소유권 이동이 일어나면서 반복자 생성
    - iter(): 소유권 이동이 일어나지 않게 레퍼런스 타입으로 참조하면서 반복자 생성
    - iter_mut(): 소유권 이동이 일어나지 않으면서 쓰기도 가능한 반복자 생성.
    */
    // ---------------------------------------------------------------------------------

    // ---------------------------------------------------------------------------------
    // 4. 레퍼런스 타입으로 함수 파라미터에 전달하기
    // 해시맵에 학생 이름 별로 점수가 들어 있다. 이 해시맵을 받아서,
    // 점수가 limit 보다 넘는 학생의 이름만을 벡터로 리턴하는 함수가 over_limit이다.
    // 70점이 넘는 학생과, 50점이 넘는 학생 이름을 구해서 출력하고자 한다.
    // 아래 코드와 같이 했을 때, let over_50 = over_limit(map,50);
    // 코드에서 value used here after move라는 에러가 발생하고 있다. 수정하시오.
    let map = HashMap::from([("Alice", 30), ("Bob", 40), ("Dave", 60), ("Jeff", 80)]);
    // let over_70 = over_limit(map, 70);
    // let over_50 = over_limit(map, 50);  //에러 map은 소유권이 없다.
    // println!("{:?}", over_70);
    // println!("{:?}", over_50);

    // 처음 over_limit(map, 70)에 의해 map의 소유권이 over_limit함수의 map으로 넘어가 버렸다.
    // 따라서, 두 번째 호출되는 over_limt(map, 50)에서 map은 소유권이 없기에 사용될 수 없다. 그래서 에러가 발생한다.
    // 그리고, over_limit 함수를 호출할 때 over_limit(&map, 70);과 같이 &를 붙여서 레퍼런스 형태로 넘겨야 한다.
    let over_70 = over_limit(&map, 70);
    let over_50 = over_limit(&map, 50);
    println!("{:?}", over_70);
    println!("{:?}", over_50);

    let over_70 = over_limit2(&map, 70);
    let over_50 = over_limit2(&map, 50);
    println!("{:?}", over_70);
    println!("{:?}", over_50);

    // ---------------------------------------------------------------------------------

    // ---------------------------------------------------------------------------------
    // ---------------------------------------------------------------------------------

    // ---------------------------------------------------------------------------------
    // ---------------------------------------------------------------------------------
}

// fn over_limit(map:HashMap<&str,i32>, limit:i32) -> Vec<String> {
fn over_limit(map: &HashMap<&str, i32>, limit: i32) -> Vec<String> {
    // over_limit 함수에서 HashMap을 레퍼런스로 받아야한다.
    let mut name: Vec<String> = Vec::new();
    for (key, value) in map {
        // if value > limit {
        if *value > limit {
            name.push(key.to_string());
        }
        // over_limit 함수에서 &HashMap으로 받았기에,
        // for (k,v) in map에 의해 받은 v는 레퍼런스 타입 입니다. 따라서, 그 값에 접근하기 위해서 *v로 해준 것이다.
    }
    name
}

fn over_limit2(map: &HashMap<&str, i32>, limit: i32) -> Vec<String> {
    map.iter()
        .filter(|(_, v)| **v > limit)
        .map(|(k, _)| k.to_string())
        .collect()
}
