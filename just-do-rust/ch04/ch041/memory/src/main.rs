fn main() {
    // 1. 스택과 힙

    // 스택 고정된 크기의 스택 프레임이 순차적으로 쌓이다가 삭제 LIFO
    // 힙 고정되지 않은 크기의 데이터블록이 할당되고, 비순차적으로 삭제될 수 있는 구조
    // 스택은 메모리 할당, 해제가 빠르고, 힙은 느림

    // 스택에는 컴파일 타임에 크기가 결정될 수 있는 데이터를 저장한다.
    // 함수에 전달되는 파라미터, 함수내에서의 지역 변수 등이 그러한 데이터.
    // 이런 값들은 컴파일 할 때 그 크기를 다 예상할 수 있다.
    // 이 스택 메모리는 사용하는 함수가 끝나면 다 정리됨
    // 해당 함수에서만 사용되는 것이기에 프로그램이 해당 영역을 지우고 다른 용도로 사용할 수 있게
    // 다 지우는 것. 메모리 관리가 쉽다.

    /*
    let s:String = String::from("hello");
    // 위와 같은 코드에 대해서 스택과 힙에 아래와 같이 저장된다.
    // 스택에는 변수명과 크기정보 그리고 포인터가 저장된다.
    // 여기서 '포인터'는 실제 데이터가 저장되어 있는 힙 메모리의 위치를 나타내는 메모리 주소

    Stack : {
        "name": "s"
        "ptr": Heap -> index 0
        "len" 5
    }
    Heap : {
        0: "h", // index 0, value "h"
        1: "e",
        2: "l",
        3: "l",
        4: "o"
     }
    */
    // 위와 같은 구조는 Rust 뿐 아니라 C나 Java도 유사한 구조
    // 이제 이 변수가 사용된 함수가 종료될 때를 생각해보자. 스택 변수의 경우는 함수가 종료될 때 전부 없애 버린다고 했다.
    // 이때, 힙에 저장된 힙 데이터를 삭제할 수 있을까?
    // 답은 "쉽지 않다"이다. C 같은 언어는 같은 힙 메모리를 가리키는 변수가 여러 개일 수 있다. 맘대로 지울 수 없다.

    // 2. 힙 메모리 관리는 어렵다.
    // C에서는 이러한 힙 메모리의 할당과 해제를 프로그래머에게 맡김
    // 프로그래머는 힙 메모리를 사용하는 배열 같은 것을 선언할 때는 malloc 함수를 써서 메모리 공간을 확보하고,
    // 이 공간을 다 써서 다시 사용할 일이 없을 때는 free를 써서 메모리를 해제해야 함.
    // 왜 프로그래머에게 맡긴 걸까? C에서의 동작구조는 힙에 동적 할당된 메모리를 언제 없애면 될 지를 알 수 없는 구조이기 때문
    //  그런데, free를 남발 할 수도 없다. 같은 메모리 공간을 중복해서 free하면
    // 'Double free'라는 문제를 야기해서 해킹에 취약한 상태를 야기함. 결국 프로그래머 실수가 많을 가능성이 있음.

    // Java에서는 이러한 힙 메모리 해제를 프로그래머가 아닌 Java Runtime이 수행하게 했다.
    // C에서의 프로그래머에 의존하는 메모리 문제가 심각해서,
    // Java 언어에서는 Java Runtime이 자동으로 메모리 해제를 하게한 것
    // 프로그램이 실행되는 중간 중간에 가비지 컬렉션이라는 작업이 자동 수행되서, 사용되지 않는 힙 메모리 공간을 해제한다.
    // 어떤 힙 공간이 사용되지 않는다는 것을 알기 위해서는 해당 공간을 가리키는 변수들을 모두 추적해서,
    // 사용되지 않는다고 100% 확신될 때만 메모리를 해제함.

    // 파이썬도 Java와 비슷한 메모리 매니저가 있어 메모리 해제를 자동으로 한다. 비슷한 문제가 있다.

    // Rust는 메모리 관리에 있어서 Java와 C의 장점을 둘 다 가져왔다. 그러면서, Java의 단점과 C의 단점을 해결했다.
    /*
    Rust에서는 Java에서와 같이 프로그래머가 아닌 자동으로 힙 메모리 해제를 한다.
    그러면서도 가비지 컬렉션이라는 복잡한 과정을 거치지 않는다.
    그냥 스택 메모리를 해제하는 것처럼 해당 힙 공간 사용이 끝나면 해당 메모리를 해제해 버린다.
    따라서, C에서와 같은 프로그래머의 미숙함/실수에 의한 메모리 해제 문제가 없고,
    자바에서 처럼 메모리 해제 루틴에 의한 성능 저하가 없다.
    */

    // ** Rust는 힙 메모리 관리 문제를 '런 타임'이 아닌 '컴파일 타임' 문제로 바꿨다. **

    /*
    Rust에서는 힙 메모리 관리에 대해서 다음과 같은 원칙을 정했다.
    이 원칙에 의해 힙 메모리 문제, 정확하게는 힙 메모리 해제관련 문제가 없거나,
    만약 있다면 컴파일 타임에 알 수 있게 했다.

    ------------------------------------------------------------
    # Rust의 힙 메모리 관리 원칙

    * 이 원칙은 Rust 컴파일러에서 체크 된다.

    생성: 힙 메모리를 사용하기로된 데이터 타입이 선언될 때, 해당 변수 정보는 스택에 저장하고, 실제 데이터는 힙에 저장한다.
    변경: 해당 변수에 대해 데이터 크기 변경이 일어날 때, 메모리 크기를 확대/축소한다.
    해제: 힙 메모리를 가리키는 변수가 해당 생존 스코프를 벗어나게 되면, 해당 힙 메모리를 해제한다.
    ------------------------------------------------------------
     */
    // 해제할 때의 원칙이 중요한데, 힙 메모리를 마치 스택 메모리를 해제하듯이, 해당 스코프를 벗어날 때 해제해 버리는 것
    // 함수 스코프로 얘기하면, 어떤 함수내에서 선언한 배열이 있다면,
    // 그 함수가 종료될 때 그 배열의 데이터가 저장되어 있는 힙 메모리 공간을 해제해 버린다는 것

    // 다른 함수 등에서 이 메모리 공간을 바라보고 있는 변수가 있으면 어떻게 하겠다는 것인가?
    // Java에서는 가비지 컬렉터가 힙 공간을 가리키는 변수가 하나도 없다는 것을 다 조사하고 난 후 해당 메모리를 해제한다.
    // 근데, Rust에서는 가비지 컬렉터도 없으면서,
    // 어떻게 그 힙 공간을 바라보고 있는 한 변수의 스코프가 종료된다고해서 힙 공간을 지울 수 있는 것인가?

    // ** 이를 위해 Rust는 두가지 개념을 새로 도입했다. 하나는 '소유권'이고 다른 하나는 '대여'다. **
    println!("Hello, Ownership");
}
