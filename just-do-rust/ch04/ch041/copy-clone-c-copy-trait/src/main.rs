fn main() {
    // C. Copy 트레잇

    // 원시타입의 경우 move가 아니라 copy가 발생
    // 그럼 왜 원시타입(primitive type)의 경우 복사(copy)가 이루어졌을까?

    /*
    이것은 원시타입 전체가 'Copy' 트레잇을 구현했기 때문이고,
    Copy 트레잇을 구현한 타입의 객체는 할당 연산자 =에 의해 다른 변수로 할당되는 경우
    스택에 있는 정보가 모두 복사되어 새로운 변수에 할당되도록 되어 있기 때문

    단, 이때도 해당 타입이 힙 메모리를 쓰는 경우 힙 메모리에 대해서는 복사가 이루어지지 않는다. 스택 데이터만 복사

    Rust에서는 스택만을 사용하는 타입은 대부분 Copy 트레잇이 이미 구현되어 있다.
    그 리스트는 여기서(https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors) 확인할 수 있는데,
    i32 u32 등 원시타입 전체와 배열, Option, Result 등이 모두 Copy 트레잇이 구현되어 있다.
    */

    /*
    Rust에서 제공하는 대부분의 데이터 타입이 Copy 트레잇을 구현하고 있기에,
    오히려 구현하지 않은 데이터 타입을 알아보는게 더 쉽다.

    Copy 트레잇을 구현하지 않는 타입은 크게 두 종류다.
    하나는 힙 메모리를 사용하는 타입들과 다른 하나는 프로그래머가 데이터 구성원(element)을 결정하는 타입

    1. 힙 메모리를 사용하는 데이터 타입: String, Vec, HashMap, Box, Rc, Arc 등
    2. 데이터 구성원을 프로그래머가 결정하는 타입: struct, enum

    이처럼 두 종류의 타입들은 할당 연산자에 의해 새로운 변수에 할당되거나,
    함수/메서드의 파라미터로 전달될 때 'copy'가 일어나지 않기에,
    소유권 이동 규칙에 의해 move가 일어난다. 즉, move후에는 원래의 변수를 사용할 수 없다.
    */

    // 예제 ------------------------------------------------------------
    #[derive(Debug)] // 구조체 객체를 {:?}을 이용해서 출력하려면 #[derive(Debug)] 속성을 부여
    struct Foo;

    let st1 = Foo;
    let st2 = st1; // 구조체는 Copy 트레잇이 자동 구현되어 있지 않기에 'move'가 발생한다. 즉, 소유권이 이동

    // println!("{:?}", st1); // error // s1은 소유권을 잃은 상태이기에, 이를 출력하려면 에러가 발생
    println!("{:?}", st2);
    // ----------------------------------------------------------------
}
