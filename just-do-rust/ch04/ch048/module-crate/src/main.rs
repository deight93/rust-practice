// 크레이트는 Rust가 컴파일되는 단위다. 크레이트는 여러 모듈을 담을 수 있고, 여러 파일로 구성될 수도 있다.

// 크레이트는 두 가지 종류가 있다.
// 하나는 '바이너리 크레이트'이고
// 다른 하나는 '라이브러리 크레이트' 이다.

// '바이너리 크레이트'는 main 함수를 포함하고 있어서 실행 가능한 프로그램으로 컴파일이 가능한 크레이트다.
//
// '라이프러리 크레이트'는 main 함수를 포함하고 있지 않아서 실행 가능한 프로그램으로 컴파일이 되지 않는다.
// 대신에 다른 프로젝트에서 공용으로 사용할 수 있는 기능들을 포함하고 있다.
// 일반적으로 '크레이트'라고 하면 '라이브러리 크레이트'를 의미한다.

// 1. 크레이트 생성
// cargo new 명령어를 통해 프로젝트가 생성될 때 크레이트도 생성이 되는데,
// cargo new <프로젝트명> --bin을 하면 '바이너티 크레이트'가 생성되고,
// cargo new <프로젝트명> --lib을 하면 라이브러리 크레이트가 생성된다.
//
// - cargo new <프로젝트명> --bin : 바이너리 크레이트 생성. src/main.rs가 생성 됨
// - cargo new <프로젝트명> --lib : 라이브러리 크레이트 생성 src/lib.rs가 생성됨
// - cargo new <프로젝트명>: --bin이 있는 것으로 간주되어 바이너리 크레이트가 생성된다.

// 2. 크레이트 루트 (crate root)
// 크레이트 루트는 '루트 모듈(root module)'을 만들어 내는 메인이 되는 소스 파일을 말한다.
// Rust 컴파일러는 크레이트를 만들기 위해 '크레이트 루트' 파일을 시작으로 해서 컴파일을 해 나간다.
// 크레이트 루트는 '바이너리 크레이트'의 경우는 'src/main.rs'가 되고,
// '라이브러리 크레이트'의 경우는 'src/lib.rs'가 된다.

/*
tip

Rust에서는 '파일명'과 '모듈명'을 1:1로 매칭해서 사용한다. 파이썬의 경우는 이렇게 하지 않는다.
소스 파일이 있다고 해서 이 소스파일명이 모듈이 되지는 않는다.
그러나, Rust에서는 소스파일이 하나의 모듈이 된다.
 */

/*
tip

패키지 안에 'src/lib.rs'가 있으면 cargo는 이 패키지가 '라이브러리 크레이트'를 가지고 있다고 판단한다.
그리고, src/main.rs가 있으면 '바이너리 크레이트'를 가지고 있다고 판단한다.
패키지는 하나의 크레이트를 가지고 있을 수도, 여러 개의 크레이트를 가지고 있을 수 있다.
 */

// 3. 복수 개의 크레이트 생성
// 만약 하나의 패키지 안에서 '바이너리 크레이트'와 '라이브러리 크레이트'를 함께 생성하려 한다면 다음과 같이 하면된다.
//
// 1) cargo new <프로젝트명>을 수행해서 바이너리 크레이트를 생성한다.
// 2) 위 1)번에 의해 src/main.rs파일은 이미 존재할 것이고, src/lib.rs파일을 수동으로 만든다.
//
// 이렇게 하고 cargo build를 하면 바이너리 실행파일과 라이브러리 파일이 둘 다 만들어 진다.

// 간단한 프로그램의 경우에는 크레이트가 하나이고(일반적으로 '바이너리 크레이트'),
// 루트 모듈(=main.rs 파일) 하나로 구성된다.
// 그러나, 프로그램이 좀 커지면 크레이트 하나를 여러 개의 모듈로 나눠서 개발된다.
// 즉, 크레이트는 여러 개의 모듈로 구성될 수 있다.

fn main() {
    println!("Hello, world!");
}
