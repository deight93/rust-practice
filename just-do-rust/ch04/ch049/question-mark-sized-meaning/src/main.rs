// ?Sized의 사용 예
// 구조체나 메서드의 정의를 보다 보면 제네릭 타입에 대해 ?Sized 키워드가 붙은 게 있다.

/*
    struct Foo<T>(T);
    struct Bar<T: ?Sized>(T);

    //reqwest 크레이트에 있는 reqwest::Client의 form 메서드 정의
    pub fn form<T: Serialize + ?Sized>(self, form: &T) -> RequestBuilder
*/

// ?Sized의 의미는 '꼭 Sized 트레잇을 구현한 타입이 아니어도 된다'의 의미다.

// 1. ?Sized 사용이유 설명
/*
    // Rust는 모든 변수에 대해서 컴파일 타임에 그 크기를 한정할 수 있어야 한다.
    // 정확하게는 스택에 할당되는 메모리 크기를 알 수 있어야 한다. 이게 어떤 의미인지를 문자열을 가지고 설명을 해 보겠다.
    //
    // Rust에서 더블 따옴표로 되어 있는 문자열은 &str 타입이다. str 타입이 아니다. 예를들어 아래와 같은 변수 선언은 불가능한다.
    // let s1: str = "Hello there!";
    // let s2: str = "How's it going?";

    // Rust 컴파일러가 위 코드에 대해 컴파일 에러를 내기에 사용할 수 없다.
    // 그런데, 왜 Rust는 문자열에 대해 str로 타입지정을 하지 않은 것일까?
    // 이유는, 위와 같은 코드를 허용하게 되면 변수 s1과 s2에 할당된 크기가 달라지게되고,
    // Rust가 이러한 것을 용납하지 않기로 했기 때문이다. Rust는 같은 타입의 변수에 대해서는 스택에 할당된 크기가 동일하길 원한다.

    // 그래서, 더블 따옴표로 문자열의 경우 실제 문자열 값은 프로그램내 읽기 전용 영역에 저장되고,
    // 그 영역을 가리키는 주소만 일정한 크기로 스택에 저장되는 것이다.
    // 즉, s1과 s2는 스택에 동일한 크기를 차지하면 존재하게 된다. 그래서 str이 아니고&str 타입이 된 것
*/

// 이처럼 Rust에서는 선언되는 변수의 크기를 컴파일 타임에 알 수 있어야 한다.
// 그리고, 각 타입마다 그 크기를 알 수 있다면 Sized 트레잇을 구현하게끔 해놨다.
// 따라서, 해당 객체의 타입이 Sized를 구현한 객체이면 컴파일 타임에 사이즈를 알 수 있는 객체다.

// Rust에서는 제네릭 타입이 선언될 때, 디폴트로 Sized를 '트레잇 바운드'를 한다.
// 즉, Sized를 구현한 타입만 제네릭 타입이 되게 하는 것이다.
//
// 예를들어 어떤 함수 test를 아래와 같이 선언한다면,
//     fn test<T>(t: T) {
//         ...
//     }
// 실제로는 아래와 같이 작성된 것으로 Rust 컴파일러 취급한다.
//     fn test<T: Sized>(t: T) {
//         ...
//     }
// 이렇게 하는 이유는, 제네릭 함수에 대해서 컴파일 타임에 스택에 할당할 공간을 알아내기 위해서다.
// 위의 경우는 test 함수의 매개변수 t가 제네릭 타입 T이고,
// 이 T 타입이 스택에 할당될 공간을 알아낼 수 있음을 보장받기 위해서, Sized 트레잇이 구현된 타입만 매개변수로 받겠다는 것이다.
//
// 그러나, 이러한 조건을 회피해야할 경우가 있다. 이때 사용하는 키워드가 ?Sized다.
// Sized앞에 ?를 붙인것인데, 트레잇 바운드 Sized 조건을 해제하는 키워드다.
// 이처럼 트레잇 앞에 ?를 붙여서 트레잇 바운드 조건을 회피하는 키워드는 Sized 트레잇에만 유일하게 쓸 수 있다.
// 즉, ?Sized가 유일한 트레잇 바운드 회피 키워드다.

// 2. ?Sized 사용 방법
// 아래는 test 함수에 대해서 ?Sized를 사용한 예다. 여기서 매개변수 t의 타입이 &T가 되었음에 유의한다.
//
//     fn test<T: ?Sized>(t: &T) {
//         // --snip--
//     }
//
// 다시 얘기하면, Rust는 컴파일 타임에 모든 변수가 차지할 스택 공간을 알아내야 한다.
// 그런데, 위와 같이 제네릭 타입에 대해 ?Sized를 사용하면, 크기를 한정할 수 없는 타입이 매개변수로 사용될 수 있음을 얘기한다.
// 그러면 컴파일러가 매개변수가 차지할 스택 공간을 알아낼 수 없다.
// 그래서 참조자 형태로 받으라고 강제하는 것이다.
// 참조자 형태가 되면, 참조하는 주소에 대한 스택 공간만 이 함수에 배정하기 때문이다.
// 따라서, 매개변수 t의 타입을 &T로 바꿔야 하는 것이다.

// 3. ?Sized를 사용해야 하는 케이스
// 그러면, 어떤 경우에 ?Sized 키워드를 사용할 필요가 있을까?
//
// 아래 예를 보자.
// 제네릭 타입 T를 사용하는 Foo라는 구조체를 선언했고,
// 이 Foo 구조체를 원소로 갖는 또 다른 구조체 FooUse1과 FooUse2가 선언되었다.
//
//     pub fn main(){
//         struct Foo<T>(T);
//
//         struct FooUse1(Foo<i32>);  //ok
//         struct FooUse2(Foo<[i32]>);  //error
//         // the size for values of type `[i32]` cannot be known at compilation time
//     }
//
// i32 타입을 원소로 갖는 배열 [i32]는 Sized를 구현하지 않는 객체다.
// 배열이기에 당연히 그 크기를 한정할 수 없기에 Sized 구현을 하지 않는 것이 맞다.
// 그리고, Rust의 제네릭 사용에서의 규칙에 의해 struct Foo<T>(T);는 실제로는 struct Foo<T:Sized>(T);로
// 트레잇 바운드가 되어 있기에, 이 T에 대한 타입으로 Sized가 구현되지 않은 [i32]가 사용되었기에 에러가 발생하는 것이다.
// 이러한 경우 [i32]도 사용되길 원한다면 Foo의 정의를 아래와 같이 바꿔야 한다.
//
//     struct Foo<T: ?Sized>(T);
//
//     struct FooUse1(Foo<i32>);  //ok
//     struct FooUse2(Foo<[i32]>); //ok

fn main() {
    println!("Hello, world!");
}
