// 정수는 그 타입에 따라 사용할 수 있는 수의 범위가 정해져 있다. u8의 경우는 0~255가 그 범위다.
// 이 범위를 벗어나는 값을 해당 변수에 넣으려고 하면 에러가 뜬다.
// 보통 정수 오버플로우(integer overflown)가 일어나면서 패닉이되어 프로그램이 중단된다.
//
// Rust에서는 이러한 정수 오버플로우가 발생했을 때 패닉을 일으켜서 프로그램이 종료되게 할 지,
// 아니면 다른 값으로 대치시키고 패닉은 일어나지 않게 할 지를 결정할 수 있다.

// 1. 오버 플로우
// u8은 0~255이고 i32는 -2**31에서 2**32-1까지 범위의 수
// 팩토리얼 값을 구한다면 12!까지는 i32의 범위이지만
// 13!에서부터는 i32의 범위를 벗어난다.
// 그렇다면 13! 등 i32의 범위를 벗어난 팩토리얼값을 요구했을 때 어떻게 처리를 해야할까?

fn factorial(n: i32) -> i32 {
    //  팩토리얼을 구하는 함수를 구현
    let mut ans = 1;
    for i in 1..=n {
        ans = ans * i;
    }
    return ans;
}

fn main() {
    println!("{:?}", factorial(3));
    println!("{:?}", factorial(12));
    // println!("{:?}", factorial(13)); // //panic 발생 // i32, attempt to multiply with overflow
    // factorial 함수에서 팩토리알 값을 계산하게 되는 ans 변수의 타입이 i32이어서,
    // factorial(13)을 계산하는 과정에서 i32의 범위를 벗어난 값이 되어 overflow가 발생한 것
    // 일반적으로 어떤 함수를 만들 때 입력값이 얼마일 때 overflow가 발생하는지를 예측하기 힘든 경우가 많기에,
    // 이처럼 입력값을 제한하는 것이 어려울 수 있다.

    // 이처럼 overflow가 발생할 때, 이 overflow가 발생하지 않게하는 것이 가장 좋겠지만,
    // 만약 발생한다면 어떻게 처리할 지를 지정할 수 있으면 좋겠다. Rust에서는 이러한 방법을 제공한다.
    // 크게 2가지인데, 위 예제에서와 같이 Panic을 발생시키는 것과, Wrapping을 하는 것이다.

    // 1. Panic: overflow가 발생했을 때 panic에 빠지게한다. 즉, 프로그램을 강제 종료 시킨다.
    // 2. Wrapping: 최댓값을 넘어가면, 최댓값을 뺀 나머지 값이 되게한다.
}

// overflow-check
// Rust는 dev 모드에서는 overflow가 발생하면 panic이 발생하는 것이 디폴트로 되어 있다.
// 그러나, 만든 프로그램을 배포하기 위해 Release 모드로 컴파일 할 때는 overflow가 발생하면 wrapping이 되게 되어 있다.

// Release 버전에 대해서도 overflow일 때 wrapping이 아닌 panic이 발생하게하려면,
// Cargo.toml 파일에서 아래와 같은 설정을 추가해줘야한다.

//     [profile.release]
//     overflow-checks = true

// Wrapping
// 릴리즈 모드에서 오버플로우가 발생했을 때, 해당 정수의 값이 wrapping이 되고 에러가 발생한다.
// 그러나, 패닉은 발생하지 않아서 프로그램이 강제 종료되진 않는다.

// wrapping이라는 것은 해당 값을 2의 보수로 처리하는 것인데,
// 0~255까지의 범위를 가지는 u8 타입의 경우 오버플로우되는 값이 아래와 같이 된다.
//
// 256 : 0
// 257: 1
// ...

/*
Rust에서 '디버그' 모드에서는 정수에 대한 오버플로우가 발생하면 패닉이 발생해서 프로그램이 강제 종료된다.
그러나, '릴리즈' 모드에서는 오버플로우가 발생하더라도 패닉에는 빠지지 않는다는 것에 유의한다.
에러가 뜨고 해당 값은 2의 보수값이 된다.
 */
