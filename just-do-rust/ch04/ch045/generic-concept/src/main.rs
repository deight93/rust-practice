// Rust에서는 제네릭(Generic)이라는 기법을 써서
// 구조체, 열거형, 함수, 메서드에서 하나의 코드로 여러 타입을 처리할 수 있게 한다.
// 제네릭을 사용하지 않으면 각 타입별로 비슷한 코드를 만들어야 한다. 코드 중복성이 높아진다.
//
// 제네릭 타입은 꺽쇠 안에 있는 어떤 문자로 표시한다. 사용되는 문자는 주로 한 개의 대문자 알파벳으로 표현된다.
// 이 문자는 특수한 의미를 가지는 것이 아니고, 동일한 타입임을 나타내는 구분자일 뿐이다.

/*
    enum Option<T> {
        Some(T),
        None,
    }
실제 Option을 사용할 때 T 자리에 i32도 올 수 있고 f64등 여러 타입이 올 수 있다는 의미다.
한 개만이 아니라 여러개도 가능하다.

    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
Result 뒤에 있는 <T, E>는 서로 다른 타입이 2개 있다는 의미다. <X, Y>라고 해도 동일하다.
T라는 타입은 Ok에 쓰이는 것이고, E라는 것은 Err에 쓰인다는 것일 뿐이다.
 */

// ------------------------------------------------------------
// struct Point {
//     x: i32,
//     y: i32,
// }

// (x,y)의 타입을 f32로 하려면 어떻게 하면 될까?
struct PointI {
    x: i32,
    y: i32,
}

struct PointF {
    x: f32,
    y: f32,
}
// 위와 같이 하면 i32타입이나 f32에 대한 (x,y) 값은 PointI 혹은 PointF 구조체로 표현할 수 있을 것이다.
// 그럼, i16에 대해서는? i8이나 f64 타입은?
// 이런 방식으로는, 타입이 늘 때마다 다른 이름의 구조체를 만들어야 한다.

// 이러한 문제를 해결하기 위한 방식이 제네릭이다. 여러 타입을 하나의 코드로 처리할 수 있게 하는 것이다.
#[derive(Debug)]
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: 5.0, y: -10.0 };

    println!("{:?}", p1);
    println!("{:?}", p2);
    // 제네릭 타입이 적용되는 것은 함수, 메서드, 구조체, 열거형
}
