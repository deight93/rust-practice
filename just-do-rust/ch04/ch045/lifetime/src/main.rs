// 주제의 내용은 '소유권과 대여' 쪽에 가까우나, 라이프타임의 표기 자체가 일종의 '제네릭'이어서 이 챕터에서 다룬다.

// 우리는 Rust의 가장 큰 특징 중 하나인 '소유권'에 대해서 알아볼 때,
// 소유권의 이동이 일어나는 것을 막기 위한 방법으로 참조자를 통한 '대여'를 한다는 것을 알아본 바 있다.
// Rust에서는 '대여 검사기(borrow checker)'라는 기법을 통해서
// 컴파일 타임에 '대여'의 유효성을 판단하고, 유효하지 않다면 에러를 낸다.
//
// 아래 예를 보자. "라이프타임이 끝난 변수"를 출력하려고 했기에 에러가 뜬다.

fn main() {
    // let r; // 변수 r은 main 함수가 끝날 때까지 수명을 같이 한다.

    {
        // let x = 5; // 변수 x는 { } 블록안의 스코프다. 블록이 끝날 때 그 수명을 다한다.
        // r = &x;
        // 블록 밖 변수 r에, 블록 안 스코프를 갖는 변수 x의 참조값을 대입했다.
        // 따라서, r은 x의 값을 참조하고 있고 x가 블록안에서만 수명을 갖는 값이기에,
        // r도 블록안에서만 수명을 갖는다. 그래서, r이 블록을 벗어나면 그 수명을 다하게된다.
    }
    // println!("r: {}", r); // 블록밖에서, 수명을 다한 r을 출력하려고 했기에 에러가 난다.

    // 즉, 코드에서 보면 r=&x라고 하면 안된다. 더 오래 살아 남는 변수 r에다가 짧은 수명의
    // 값 x를 참조하게 되면, 나중에 r을 사용하려고 할 때 짧은 수명의 x는 이미 수명을 다했기에 접근할 수 없기 때문이다.

    /*
    댕글링 참조

    위 예제에서 이미 수명이 다한 변수를 참조하는 것을 '댕글링 참조', 혹은 '댕글링 포인터'라고 하고,
    C 언어에서 프로그램을 잘못짜면 종종 발생하는 문제다. Rust에서는 이러한 댕글링 참조가 일어나지 않도록
    컴파일 타임에 이러한 것을 미리 체크하고, 댕글링 참조가 일어날 수 있는 가능성이 보이면 컴파일 에러를 낸다.
    즉, Rust에서는 이러한 댕글링 참조 문제를 컴파일러가 걸러주기에, 아예 발생하지 않는다. 좋은 언어다. ^^
     */
    let x = 5;
    let r = &x;

    println!("r: {}", r);

    // 컴파일러가 어느 쪽이 라이프타임이 긴 지 짧은 지를 자동으로 파악할 수 없는 경우가 있다.
    // 이 경우는 프로그래머가 직접 해당 변수에 대한 라이프타임을 지정해줘야 한다.
    // Rust 언어가 다른 언어와 다른 또 한가지 특성이다.

    let x = String::from("123");
    // (1) (1) x와 y를 그냥 let x="123";, let y="45678"이라고 안하고 String으로 선언했다.
    // longest 함수에 String의 레퍼런스로 전달하기 위해서다.
    // 그냥 let x="123"이라고 하면 x의 타임은 &'static str이되어 라이프타임이 영구인 참조자가 되어 버려서,
    // 여기서 시험해보고자 하는 라이프타임 문제를 테스트할 수 없다.
    let y = String::from("45678");
    let s = longest(x.as_str(), y.as_str());
    // (2)  String 객체의 참조값을 얻어낼 때는 as_str()을 사용하면 된다.
    println!("longest is : {}", s);
}

// fn longest(s1: &str, s2: &str) -> &str {
/*
   48 | fn longest(s1: &str, s2: &str) -> &str {
  |                ----      ----     ^ expected named lifetime parameter
*/
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    // 일단 컴파일러가 가이드해주는데로 라이프타임 파라미터를 넣어보도록 하자.
    // 가이드에는 함수로 들어오는 파라미터 2개와 리턴값에 모두 동일한 라이프타임인 'a로 하도록 되어 있다.
    // 리턴되는 값의 라이프타임을 s1과 s2의 라이프타임과 같게 하라는 의미다.
    // 더 정확하게는 둘 중 더 작은 라이프타임과 동일하게 하라는 의미다.

    if s1.len() > s2.len() { s1 } else { s2 }

    // longest 함수에서 if~else 구분에 의해서, 리턴되는 것은 s1일 수도 있고 s2일 수도 있다.
    // 무엇이 리턴될 지는 컴파일 시점에서는 알 수 없다.
    // 컴파일러가 s1.len()과 s2.len()을 실행해보고 if~else 구문을 실행하지는 않기 때문이다.
    // 이것은 실행 시점에라야 리턴값이 s1일지 s2일지 결정된다.

    // 따라서, longest가 리턴하는 값에 대한 라이프타임을 s1의 라이프타임으로 할 지,
    // s2의 라이프타임으로 할 지 알 수 없다.
    // 그래서, 컴파일러는 프로그래머에게 "대여 검사기로 확인할 수 없는 상황이니 유의하고,
    // 프로그래머가 직접 라이프타임 파라미터를 넣으라"라고 에러 메시지를 보내는 것이다

    //--------------------------------------
    // let x = String::from("123");
    // let s;
    // {
    //     let y = String::from("45678");
    //     s = longest(x.as_str(), y.as_str());
    // }
    // println!("longest is : {}", s); //error

    /*
    위 코드를 보면, y를 블록 안에 선언했다. 그리고, y가 더 긴 문자열이라서 longest의 리턴은 y가 된다.
    그런데, y는 블록안에서 선언되었기에 블록 안에서만 라이프타임을 갖기에, 블록 밖에서 사용되면 안된다.

    여기서, longest를 선언할 때 'a를 사용해서, 리턴값의 라이프타임을s1과 s2 중 더 작은 라이프타임과 같다고 선언을 해줬다.
    따라서, longest의 결과를 받은 변수 s의 라이프타임은 s1과 s2 중 더 작은 라이프타임인 y의 라이프타임이 될것이다.
    실제 실행결과가 그렇다는 것이 아니고 컴파일 타임에서 라이프타임을 예측할 때 그렇다는 것이다.
    컴파일 타임에는 실제 s2가 리턴될 것이라는 것을 모른다.

    단지, 프로그래머가 'a로 리턴값의 라이프타임이 s1과 s2 중 더 작은 라이프타임을 가진 것으로하자고 선언했기에,
    변수 s의 라이프타임이 s2 즉, y의 라이프타임과 같게 된 것 뿐이다.

    이제 longest의 결과를 받은 변수 s의 라이프타임은 y와 같게 되었고,
    y는 블록안에서만 유효해서 변수 s의 라이프타임도 역시 블록안에서만 유효한데,
    블록 밖에서 s를 출력하려고 하니 에러가 날 것이다.

    이러한 목적으로 프로그래머에게 직접 리턴값에 대해 라이프타임 파라미터를 이용해서 라이프타임을 지정하라고 한 것이다.
    발생할 수 있는 댕글링 포인터 문제를 컴파일 타임에 잡아내려는 노력이다.

    그럼, 아래 예제에 대해서는 어떻게 될까?
    위에 있는 [코드 4]에서는 더 긴 문자열을 블록안에 선언했고,
    이 긴 문자열이 longest의 리턴값이 되었고, 블록을 벗어나서 이 값을 출력하려고 하니 에러가 뜬 것이다.
    아래 [코드 5]는 블록안에 더 짧은 문자열을 선언한 것이다. 이 경우는 어떻게 될까?
     */
    //--------------------------------------
    // let y = String::from("45678");
    // let s;
    // {
    //     let x = String::from("123");
    //     s = longest(x.as_str(), y.as_str());
    // }
    // println!("longest is : {}",s);

    /*
    위 [코드 5]에 대해서도 에러가 뜬다. 코드 상으로 보면, 더 큰 문자열인 y가 블록 밖에 선언되어 있고,
    longest의 결과로 y가 리턴되어 변수 s에는 y가 할당될 것이기에, 블록 밖에서 s를 출력해도 문제 없을 것 같다.

    그러나, 컴파일러 입장에서는, longest의 선언에 있어, 리턴 값은 두 파라미터 중 더 작은 라이프타임으로 한다고 되어 있기에,
    longest의 리턴값을 받은 변수 s의 라이프타임은 x와 y중 라이프타임이 더 작은 x의 라이프타임으로 되어 버린다.

    그렇기에, 블록 밖에서 s를 출력하려는 시도에 대해서 에러를 내는 것이다.
     */
}

/*
여기서 모두 동일한 라이프타임인 'a로 지정한 것이 왜 "둘 중 더 작은 라이프타임과 동일"하게 지정한 것이 된 것이지 의아할 수 있다.
longest 함수에서 s1의 실제 라이프타임을 'x로, s2의 라이프타임을 'y라고 생각해 보자.
그런데, longest 함수의 코드에서 s1 및 s2 그리고
리턴값에 대한 라이프타임을 'a로 통일했기에 'a라는 라이프타임은 ['x, 'y]를 모두 포함한 개념이된다.

이제 longest 함수의 리턴값을 어떤 변수에 할당한다고 하자.
(함수의 리턴값이 사용되는 것은 항상, 다른 어떤 변수에 대입되거나 계산식에 사용될 뿐이다.)
그 어떤 변수의 라이프타임을 'b라고 하면, 리턴값의 라이프타임은 'b보다 길어야한다. 그래야 할당이 된다고 위 쪽에서 정의를 내렸었다.

즉, 리턴값의 라이프타임은 'a=['x,'y]인 상태에서, 다른 라이프타임 'b를 비교한다면, 'a >= 'b 라야하고,
이 얘기는 'a=['x,'y] >= 'b라야하고, 이 식을 만족한다는 것은 ['x,'y] 중에
가장 작은 라이프타임에 대해서도 'b보다는 커야함을 의미한다.

따라서, 라이프타임이 ['x,'y]로 다른 두 파라미터 s1과 s2에 대해서 동일한 라이프타임 변수인
'a로 했다는 것은 둘 중 더 작은 라이프타임과 동일하게 했다는 것과 같은 의미가 되는 것이다. (그렇게 생각하는 것이 편하다는 의미)

    fn longest<'a>(s1:&'a str, s2:&'a str) -> &'a str {
        if s1.len() > s2.len() { s1 }
        else { s2 }
    }

그런데, 왜 컴파일러는 longest의 리턴값이 s1일지 s2일지 모른다고하면서 프로그래머에게
직접 라이프타임 파라미터를 넣으라고 하는걸까? s1일지 s2일지 모른다는 것이 무슨 문제를 일으키기에 그렇게 하는걸까?
 */

/*
tip

라이프타임 파라미터를 부여했다고 해서 실제 라이프타임이 변하는 것은 아니다.
실행 시점에서 해당 변수의 스코프에 따라 실제 라이프타임은 결정된다.
여기서 부여하는 라이프타임 파라미터는 컴파일러를 위한 것이다. 컴파일러가 댕글링 포인터를 잡아내기 위해서 '대여 검사'를 할 때,
컴파일러가 판단하지 못하는 것에 대해서 프로그래머가 유의해서 라이프타임을 지정해보라는 것이다.
그렇게 지정한 라이프타임을 가지고 컴파일러가 '대여 검사'를 해 보려는 것이다.
 */
