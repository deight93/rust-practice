/*
라이프타임 파라미터는 일종의 '제네릭'이다. 따라서, 제네릭 표기법과 유사하다.
다만 라이프타임 매개변수의 이름을 어퍼스트로피(')로 시작한다는 점만 다른다.
일반 제네릭 변수와 구별하기 위한 방법이다.

라이프타임 매개변수는 참조자의 & 뒤에 위치하며,
공백을 한 칸 입력하여 참조자의 타입과 분리한다.

제네릭에서 변수 이름을 정할 때와 동일하게 소문자를 주로 쓰고,
첫 번째 변수는 'a 두 번째는 'b와 같이 표기한다.
아래는 i32 타입과 str에 대해서 라이프타임을 표기한 예다.

&'a i32
&'a mut i32

&'a str
 */

// 함수에서의 라이프타임 표기
// 함수에서는 리턴값이 참조 타입의 경우,
// 무조건 입력되는 파라미터의 라이프타임을 가지고 표기해야 한다.

/*
참조값을 리턴하는데 입력 파라미터와 관련 없을 수 있을까?

리턴값이 입력 파라미터 중 하나가 아닌 경우는, 함수내에서 만든 변수에 대한 참조자를 반환하는 경우 밖에 없다.
이 경우는, 함수 내에서 생성한 변수의 수명이 함수 내에서만 유효하기에,
이 변수에 대한 참조자를 반환하면 문제가 발생한다. 댕글링 포인터이기 때문이다.

따라서, Rust 컴파일러는 이런 경우 컴파일 에러를 낸다.
즉, 함수에서 참조자를 리턴하는데, 이 참조자가 입력 파라미터의 참조자가 아닌 경우는 없다.
 */

/*
앞에서 살펴봤던 longest 함수에서는, 두 개의 입력 파라미터 중
"수명이 짧은 파라미터의 라이프타임과 같다"는 의미의 라이프타임 표기를 했었다.
동일한 라이프타임 매개변수를 사용한 것이다.

fn longest<'a>(s1:&'a str, s2:&'a str) -> &'a str {
만약 입력되는 두 문자열 중에서, 첫 번째 문자열의 참조자를 리턴한다면
아래와 같이 입력 파라미터 하나와 리턴값의 라이프타임을 맞춰 주면 된다.
 */

fn main() {
    let x = String::from("123");
    let s;
    {
        let y = String::from("45678"); //  y를 블록안에 선언했다.
        s = first_str(x.as_ref(), y.as_ref());
        // first_str이 실제 리턴값은 y가 아닐 것이고, 또한 firtst_str에서의 라이프타임 지정이
        // 첫 번째 파라미터와 같게 되어 있기에, 변수 s의 라이프타임은 x와 같게 된다.
    }
    println!("The first string is : {}", s);

    let x = String::from("123");
    let s;
    {
        let y = String::from("45678");
        s = firt_str(x.as_ref(), y.as_ref());
    }
    println!("The first string is : {}", s);
}

fn first_str<'a>(s1: &'a str, s2: &str) -> &'a str {
    // first_str에서 리턴되는 참조자의 라이프타입을 첫 번째 입력 파라미터와 같다고 지정했다.
    println!("s2={}", s2);
    s1
}

// fn firt_str<'a>(s1: &'a str, s2: &'a str) -> &'a str {
fn firt_str<'a>(s1: &'a str, s2: &str) -> &'a str {
    // 리턴되는 참조자의 라이프타임을 첫 번째 문자열하고만 같게
    println!("s2={}", s2);
    s1
    /*
    코드를 해석해 보면 런 타임에서 first_str을 호출했을 때 무조건 첫 번째 문자열이 리턴 될 것이기에,
    s = firt_str(x.as_ref(), y.as_ref()); 이라고 했을 때 s의 값으로는 x.as_ref()가 될 것이 자명하다.

    그러나, 컴파일러의 '대여 검사기'가 보는 것은 함수에서 리턴되는 참조자의 라이프타임 뿐이다.
    여기서는 리턴되는 참조자의 라이프타임을 두 입력 파라미터와 같은 것으로 했다.
    이 의미는 두 입력 파라미터의 라이프타임 중 작은 것을 따르게 된다.
    라이프타임이 작은 것은 y다. 따라서, first_str의 결괏값을 받은 변수 s의 라이프타임은 y와 같게 된다.

    따라서, s의 라이프타임이 블록안에만 존재하는데, 블록 밖에서 이 s를 출력하려고 시도했기에 에러가 나는 것이다.
    이처럼 컴파일러는 라이프타임만을 볼 뿐이고, 실제 수행되는 로직을 수행해 볼 수는 없는 것이기에,
    코드로 보기에는 자명하게 라이프타임이 긴 x가 s로 될 것이라도,
    라이프타임에 따라 댕글링 포인터 문제가 예상되기에 에러를 내 버리는 것이다.

    이런 경우 어떻게 해야하는가?
    first_str 함수가 리턴하는 것이 첫 번째 문자열이기에,
    리턴되는 참조자의 라이프타임을 첫 번째 문자열하고만 같게 설정해주면 되는 것이다.

    //    fn firt_str<'a>(s1:&'a str, s2:&str) -> &'a str {

    지금까지 함수에서의 라이프타임 표기를 어떻게 하는지 알아봤다.
    함수가 참조자를 리턴하는 경우에만 해당하는 사항으로, 리턴되는 참조자가 과연 어떤 입력 파라미터의 라이프타임과
    같은지를 프로그래머가 지정해주라는 것이다. 파라미터가 하나인 경우는 라이프타임 표기를 요구하지 않는다.
    왜냐면 리턴되는 참조자는 무조건 하나 뿐인 입력 파라미터의 라이프타임과 같을 것이기 때문이다.
     */
}

/*
함수에서 참조자가 리턴되면서, 입력 파라미터의 갯수가 2개 이상일 때 프로그래머는 리턴되는 참조자의 라이프타임 표기를 해야하고,
일반적으로는 입력되는 파라미터들과 동일한 라이프타임을 지정해서,
입력 파라미터 중 가장 짧은 라이프타임과 동기화를 시키면 된다.

그러나, 리턴되는 참조자가 입력 파라미터 중 특수한 것 하나일 것이 자명한 경우는
해당 입력 파라미터의 라이프타임하고만 동기화를 하면 되겠다.
 */
