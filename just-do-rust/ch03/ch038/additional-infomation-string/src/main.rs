fn main() {
    // 1. 문자열 리터럴 (String Literal)에 대한 이해
    // 쌍 따옴표 "..."로 묶여 있는 문자열을 '문자열 리터럴'이라고 한다. Rust에서 문자열 리터럴은 &'static str타입

    // 일반 String에 대한 슬라이스가 '&str'인데 반해 'static이 더 들어가 있다.
    // static이라는 것은 이 데이터는 프로그램이 종료되기 전까지 소멸되지 않는 데이터라는 의미다.
    // 왜냐면 '문자열 리터럴'은 프로그램의 '읽기 전용' 메모리 공간에 존재하기 때문
    let person: &'static str = "Rust";
    println!("{}", person);

    // 'String'과 String Literal은 모두 스택 공간에 참조자가 있고, 실제 문자 정보는 다른 메모리 공간에 있다.
    // 그런데, String의 문자 정보는 '힙'에 존재하고, String Literal의 문자 정보는 '읽기 전용' 메모리 공간에 존재한다.
    // 그리고 String에 대한 슬라이스를 하게되면, 역시 그 참조 정보는 스택에 존재하고, 슬라이스된 문자 정보는 힙에 존재
    let phone_num: String = String::from("010-123-4567"); // String
    let num4: &str = &phone_num[8..]; // 문자열 슬라이스(String Slice)
    println!("{}\n", num4);
    // 문자열 리터럴의 문자 정보가 저장되는 '읽기 전용' 메모리 공간은 프로그램이 메모리에 적재될 때
    // 할당되는 '데이터 세그먼트'라는 공간으로, 이 영역은 읽기 전용

    // 2. 이스케이프 문자 (escape character)
    // 이스케이프(escape)의 사전적 의미는 '뭔가 규칙을 벗어나는'이다.
    /*
    프로그램 언어에서 이스케이프 문자는 '보이는 그대로가 아니고, 다른 의미를 가진 문자'이다.
    예를들어 \n은 "슬래시가 있고 그 다음에 문자 n이 있는" 보이는 그대로의 의미가 아니고 "줄을 바꾼다"는 의미를 가지는 약속어다.
    이처럼 이스케이프 문자는 '백슬래시'가 있고 그 뒤에 어떤 문자가 있게 되는 형태인데,
    각 문자에 따라서 어떤 의미를 가지는지 약속해 놨다.

    Rust에서는 C 언어에서 사용하는 이스케이프 문자 스타일을 따른다. 대표적인 문자
    \r - carriage return  줄 바꿈
    \n - line feed    줄 바꿈
    \t - tab
    \\ - backslash
    \0 - null
    \' - single-quote

    이스케이프 문자가 운영체제마다 약간씩 다르다
    \r : CR(Carrage Return) 예전 Mac OS에서의 줄 바꿈 문자
    \n: LF(Line Feed) Unix와 Mac OS X에서의 줄 바꿈 문자.
    \r\n: CRLF(Carrage Return and Line Feed) Windows에서의 줄 바꿈 문자

    Rust에서는 \n과 \r\n이 줄 바꿈 문자다.
    (정확하게는 \n이 줄 바꿈 문자이고, \r\n은 \n으로 취급되서 줄 바꿈 문자가 되는 것이다.)
    */
    let s1 = "112345678\nabc"; //줄 바뀜
    println!("{}\n", s1);

    let s2 = "212345678\rabc"; //줄 바뀌지 않음 abc345678
    println!("{}\n", s2);

    let s3 = "312345678\r\nabc"; //줄 바뀜
    println!("{}\n", s3);

    // 3. 멀티 라인
    // 문자열 리터럴에는 개행문자(줄 바뀜 문자)를 포함.
    // 예를들어 아래와 같은 코드에서 변수 s에는 개행문자 \n이 2개 들어가서 문자열 리터럴이 된다.
    // \n의 아스키 값은 16진수로는 0x0A이고, 십진수로는 10이다.
    let s = "123
456
789";
    println!("{}", s);
    println!("{}", s.len());
    println!("{:?}", s.bytes());

    // 문자열 리터럴에는 '개행 문자'가 들어가지 않게 하려면 \를 문자열 리터럴 안에 넣으면 된다.
    // '\'를 사용했기에 보기에는 줄이 바껴서 입력된 듯 보이나 실제 s의 값에는 개행문자가 들어가지 않는다.
    let s = "123\
456\
789";
    println!("{}", s);
    println!("{}", s.len());
    println!("{:?}", s.bytes());

    // 4. 문자열을 문자로 변환하기
    // 문자열 리터럴은 문자의 집합인데, 이를 어떻게 표현하느냐에 따라 메모리에 저장되는 '문자' 형태가 달라진다.
    /*
    항목            | 표현 방법       | 문자 코드    | 설명
    ---------------|---------------|-----------|--------------------------------------------------
    문자열 리터럴     | "hello\n"     | 유니코드     | - 이스케이프 문자가 있으면 이를 처리.
                   |               |            |  즉, \n을 개행문자로 인식
    ---------------|---------------|------------|--------------------------------------------------
    원시 문자열       | r#"hello\n"#  | 유니코드     | - 쌍 따옴표 안에 있는 문자를 모두 문자 자체로 인식.
                   |               |            |  즉, 이스케이프 문자를 인식하지 않고 그냥 \n과 같은 문자로 인식
    ---------------|---------------|------------|--------------------------------------------------
    바이트 문자열     | b"hello\n"     | 아스키      | - 문자열을 바이트 값으로 저장.
                   |                |           | - 이스케이프 문자를 인식.
                   |                |           | - 아스키 코드만 있어서 b"헬로우" 같은 유니코드 문자를 처리 못함
    ---------------|---------------|------------|--------------------------------------------------
    원시 바이트 문자열  | br#"hello\n"# | 아스키     | - 이스케이프 문자를 실제 문자로 인식하는 바이트 문자열
    ---------------|---------------|------------|--------------------------------------------------
    C 스타일 문자열    | c"hello\n"    | 유니코드    | - 문자열을 바이트 값으로 저장.
                    |               |           | - 이스케이프 문자를 인식.
                    |               |           | - 아스키 코드가 아닌 유니코드 지원.
                    |               |           | - 따라서 c"헬로우" 같은 유니코드 문자를 처리 가능
    ----------------|---------------|------------|--------------------------------------------------
    원시 C 스타일 문자열 | cr#"hello\n"# | 유니코드     | - 이스케이프 문자를 실제 문자로 인식하는 C 스타일 문자열
    ----------------|---------------|------------|--------------------------------------------------

    위 표에서 '원시 문자열'을 처리하는 부분은 눈여겨 볼 만하다.
    예를들어 HTML 문서를 문자열로 표현하는 경우 '원시 문자열' 방식을 사용해야 제대로 처리할 수 있다.
    HTML 문자열에는 꺽쇄 < >도 있고해서 그냥 일발적인 문자열 처럼 쌍 따옴표만을 사용했을 때는 에러가 뜬다. 아래는 그 사용 예다.
     */

    let a: &'static str = r#"
        <div class="advice">
            Raw srings are useful for some situations.
        <div>
        "#;
    println!("{}", a);

    //5. 파일을 문자열로 읽어 들이기
    // 파일에 있는 문자열을 읽어 들일 때는, 일반적인 방법으로 파일을 오픈하고 read 함수를 써서 읽을 수도 있으나,
    // include_str! 매크로를 이용하면 쉽고 빠른 속도로 문자열을 읽어 낼 수 있다.
    let hello_html = include_str!("../hello.html");
    println!("{}", hello_html);
}
